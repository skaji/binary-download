#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp;our$VERSION='0.2311';use 5.006;use strict;use Carp;use File::Spec 0.8;use Cwd ();use File::Path 2.06 qw/rmtree/;use Fcntl 1.03;use IO::Seekable;use Errno;use Scalar::Util 'refaddr';require VMS::Stdio if $^O eq 'VMS';eval {require Carp::Heavy};require Symbol if $] < 5.006;use parent 0.221 qw/IO::Handle IO::Seekable/;use overload '""'=>"STRINGIFY",'0+'=>"NUMIFY",fallback=>1;our$DEBUG=0;our$KEEP_ALL=0;use Exporter 5.57 'import';our@EXPORT_OK=qw{tempfile tempdir tmpnam tmpfile mktemp mkstemp mkstemps mkdtemp unlink0 cleanup SEEK_SET SEEK_CUR SEEK_END};our%EXPORT_TAGS=('POSIX'=>[qw/tmpnam tmpfile/],'mktemp'=>[qw/mktemp mkstemp mkstemps mkdtemp/],'seekable'=>[qw/SEEK_SET SEEK_CUR SEEK_END/],);Exporter::export_tags('POSIX','mktemp','seekable');my@CHARS=(qw/A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 _/);use constant MAX_TRIES=>1000;use constant MINX=>4;use constant TEMPXXX=>'X' x 10;use constant STANDARD=>0;use constant MEDIUM=>1;use constant HIGH=>2;my$OPENFLAGS=O_CREAT | O_EXCL | O_RDWR;my$LOCKFLAG;unless ($^O eq 'MacOS'){for my$oflag (qw/NOFOLLOW BINARY LARGEFILE NOINHERIT/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);no strict 'refs';$OPENFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}$LOCKFLAG=eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};&Fcntl::O_EXLOCK()}}my$OPENTEMPFLAGS=$OPENFLAGS;unless ($^O eq 'MacOS'){for my$oflag (qw/TEMPORARY/){my ($bit,$func)=(0,"Fcntl::O_" .$oflag);local($@);no strict 'refs';$OPENTEMPFLAGS |= $bit if eval {local$SIG{__DIE__}=sub {};local$SIG{__WARN__}=sub {};$bit=&$func();1}}}my%FILES_CREATED_BY_OBJECT;sub _gettemp {croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);' unless scalar(@_)>= 1;my$tempErrStr;my%options=("open"=>0,"mkdir"=>0,"suffixlen"=>0,"unlink_on_close"=>0,"use_exlock"=>0,"ErrStr"=>\$tempErrStr,"file_permissions"=>undef,);my$template=shift;if (ref($template)){carp "File::Temp::_gettemp: template must not be a reference";return ()}if (scalar(@_)% 2!=0){carp "File::Temp::_gettemp: Must have even number of options";return ()}%options=(%options,@_)if @_;${$options{ErrStr}}=undef;if ($options{"open"}&& $options{"mkdir"}){${$options{ErrStr}}="doopen and domkdir can not both be true\n";return ()}my$start=length($template)- 1 - $options{"suffixlen"};if (substr($template,$start - MINX + 1,MINX)ne 'X' x MINX){${$options{ErrStr}}="The template must end with at least ".MINX ." 'X' characters\n";return ()}my$path=_replace_XX($template,$options{"suffixlen"});my ($volume,$directories,$file);my$parent;if ($options{"mkdir"}){($volume,$directories,$file)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);if ($#dirs==0){$parent=File::Spec->curdir}else {if ($^O eq 'VMS'){$parent=File::Spec->catdir($volume,@dirs[0..$#dirs-1]);$parent='sys$disk:[]' if$parent eq ''}else {$parent=File::Spec->catdir(@dirs[0..$#dirs-1]);$parent=File::Spec->catpath($volume,$parent,'')}}}else {($volume,$directories,$file)=File::Spec->splitpath($path);$parent=File::Spec->catpath($volume,$directories,'');$parent=File::Spec->curdir unless$directories ne ''}unless (-e $parent){${$options{ErrStr}}="Parent directory ($parent) does not exist";return ()}unless (-d $parent){${$options{ErrStr}}="Parent directory ($parent) is not a directory";return ()}if (File::Temp->safe_level==MEDIUM){my$safeerr;unless (_is_safe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}elsif (File::Temp->safe_level==HIGH){my$safeerr;unless (_is_verysafe($parent,\$safeerr)){${$options{ErrStr}}="Parent directory ($parent) is not safe ($safeerr)";return ()}}my$perms=$options{file_permissions};my$has_perms=defined$perms;$perms=0600 unless$has_perms;for (my$i=0;$i < MAX_TRIES;$i++){if ($options{"open"}){my$fh;if ($] < 5.006){$fh=&Symbol::gensym}local $^F=2;my$open_success=undef;if ($^O eq 'VMS' and $options{"unlink_on_close"}&&!$KEEP_ALL){$fh=VMS::Stdio::vmssysopen($path,$OPENFLAGS,$perms,'fop=dlt');$open_success=$fh}else {my$flags=(($options{"unlink_on_close"}&&!$KEEP_ALL)? $OPENTEMPFLAGS : $OPENFLAGS);$flags |= $LOCKFLAG if (defined$LOCKFLAG && $options{use_exlock});$open_success=sysopen($fh,$path,$flags,$perms)}if ($open_success){chmod($perms,$path)unless$has_perms;return ($fh,$path)}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create temp file $path: $!";return ()}}}elsif ($options{"mkdir"}){if (mkdir($path,0700)){chmod(0700,$path);return undef,$path}else {unless ($!{EEXIST}){${$options{ErrStr}}="Could not create directory $path: $!";return ()}}}else {return (undef,$path)unless -e $path}my$original=$path;my$counter=0;my$MAX_GUESS=50;do {$path=_replace_XX($template,$options{"suffixlen"});$counter++}until ($path ne $original || $counter > $MAX_GUESS);if ($counter > $MAX_GUESS){${$options{ErrStr}}="Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";return ()}}${$options{ErrStr}}="Have exceeded the maximum number of attempts (" .MAX_TRIES .") to open temp file/dir";return ()}sub _replace_XX {croak 'Usage: _replace_XX($template, $ignore)' unless scalar(@_)==2;my ($path,$ignore)=@_;my$end=($] >= 5.006 ? "\\z" : "\\Z");if ($ignore){substr($path,0,- $ignore)=~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}else {$path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge}return$path}sub _force_writable {my$file=shift;chmod 0600,$file}sub _is_safe {my$path=shift;my$err_ref=shift;my@info=stat($path);unless (scalar(@info)){$$err_ref="stat(path) returned no values";return 0};return 1 if $^O eq 'VMS';if ($info[4]> File::Temp->top_system_uid()&& $info[4]!=$>){Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",File::Temp->top_system_uid());$$err_ref="Directory owned neither by root nor the current user" if ref($err_ref);return 0}if (($info[2]& &Fcntl::S_IWGRP)|| ($info[2]& &Fcntl::S_IWOTH)){unless (-d $path){$$err_ref="Path ($path) is not a directory" if ref($err_ref);return 0}unless (-k $path){$$err_ref="Sticky bit not set on $path when dir is group|world writable" if ref($err_ref);return 0}}return 1}sub _is_verysafe {require POSIX;my$path=shift;print "_is_verysafe testing $path\n" if$DEBUG;return 1 if $^O eq 'VMS';my$err_ref=shift;local($@);my$chown_restricted;$chown_restricted=&POSIX::_PC_CHOWN_RESTRICTED()if eval {&POSIX::_PC_CHOWN_RESTRICTED();1};if (defined$chown_restricted){return _is_safe($path,$err_ref)if POSIX::sysconf($chown_restricted)}unless (File::Spec->file_name_is_absolute($path)){$path=File::Spec->rel2abs($path)}my ($volume,$directories,undef)=File::Spec->splitpath($path,1);my@dirs=File::Spec->splitdir($directories);for my$pos (0.. $#dirs){my$dir=File::Spec->catpath($volume,File::Spec->catdir(@dirs[0.. $#dirs - $pos]),'');print "TESTING DIR $dir\n" if$DEBUG;return 0 unless _is_safe($dir,$err_ref)}return 1}sub _can_unlink_opened_file {if (grep $^O eq $_,qw/MSWin32 os2 VMS dos MacOS haiku/){return 0}else {return 1}}sub _can_do_level {my$level=shift;return 1 if$level==STANDARD;if ($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix'){return 0}else {return 1}}{my (%files_to_unlink,%dirs_to_unlink);END {local($.,$@,$!,$^E,$?);cleanup(at_exit=>1)}sub cleanup {my%h=@_;my$at_exit=delete$h{at_exit};$at_exit=0 if not defined$at_exit;{my@k=sort keys%h;die "unrecognized parameters: @k" if@k}if (!$KEEP_ALL){my@files=(exists$files_to_unlink{$$}? @{$files_to_unlink{$$}}: ());for my$file (@files){close($file->[0]);if (-f $file->[1]){_force_writable($file->[1]);unlink$file->[1]or warn "Error removing ".$file->[1]}}my@dirs=(exists$dirs_to_unlink{$$}? @{$dirs_to_unlink{$$}}: ());my ($cwd,$cwd_to_remove);for my$dir (@dirs){if (-d $dir){if ($at_exit){$cwd=Cwd::abs_path(File::Spec->curdir)if not defined$cwd;my$abs=Cwd::abs_path($dir);if ($abs eq $cwd){$cwd_to_remove=$dir;next}}eval {rmtree($dir,$DEBUG,0)};warn $@ if ($@ && $^W)}}if (defined$cwd_to_remove){chdir$cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";my$updir=File::Spec->updir;chdir$updir or die "cannot chdir to $updir: $!";eval {rmtree($cwd_to_remove,$DEBUG,0)};warn $@ if ($@ && $^W)}@{$files_to_unlink{$$}}=()if exists$files_to_unlink{$$};@{$dirs_to_unlink{$$}}=()if exists$dirs_to_unlink{$$}}}sub _deferred_unlink {croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)' unless scalar(@_)==3;my ($fh,$fname,$isdir)=@_;warn "Setting up deferred removal of $fname\n" if$DEBUG;$fname=Cwd::abs_path($fname);($fname)=$fname =~ /^(.*)$/;if ($isdir){if (-d $fname){$fname=VMS::Filespec::vmspath($fname)if $^O eq 'VMS';$dirs_to_unlink{$$}=[]unless exists$dirs_to_unlink{$$};push (@{$dirs_to_unlink{$$}},$fname)}else {carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W}}else {if (-f $fname){$files_to_unlink{$$}=[]unless exists$files_to_unlink{$$};push(@{$files_to_unlink{$$}},[$fh,$fname])}else {carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W}}}}sub _parse_args {my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map +(uc($_)=>$args{$_}),keys%args;my@template=(exists$args{TEMPLATE}? $args{TEMPLATE}: $leading_template ? $leading_template : ());delete$args{TEMPLATE};return(\@template,\%args)}sub new {my$proto=shift;my$class=ref($proto)|| $proto;my ($maybe_template,$args)=_parse_args(@_);my$unlink=(exists$args->{UNLINK}? $args->{UNLINK}: 1);delete$args->{UNLINK};delete$args->{OPEN};my ($fh,$path)=tempfile(@$maybe_template,%$args);print "Tmp: $fh - $path\n" if$DEBUG;${*$fh}=$path;$FILES_CREATED_BY_OBJECT{$$}{$path}=1;%{*$fh}=%$args;bless$fh,$class;$fh->unlink_on_destroy($unlink);return$fh}sub newdir {my$self=shift;my ($maybe_template,$args)=_parse_args(@_);my$cleanup=(exists$args->{CLEANUP}? $args->{CLEANUP}: 1);delete$args->{CLEANUP};my$tempdir=tempdir(@$maybe_template,%$args);my$real_dir=Cwd::abs_path($tempdir);($real_dir)=$real_dir =~ /^(.*)$/;return bless {DIRNAME=>$tempdir,REALNAME=>$real_dir,CLEANUP=>$cleanup,LAUNCHPID=>$$,},"File::Temp::Dir"}sub filename {my$self=shift;return ${*$self}}sub STRINGIFY {my$self=shift;return$self->filename}sub NUMIFY {return refaddr($_[0])}sub unlink_on_destroy {my$self=shift;if (@_){${*$self}{UNLINK}=shift}return ${*$self}{UNLINK}}sub DESTROY {local($.,$@,$!,$^E,$?);my$self=shift;my$file=$self->filename;my$was_created_by_proc;if (exists$FILES_CREATED_BY_OBJECT{$$}{$file}){$was_created_by_proc=1;delete$FILES_CREATED_BY_OBJECT{$$}{$file}}if (${*$self}{UNLINK}&&!$KEEP_ALL){print "# --------->   Unlinking $self\n" if$DEBUG;return unless$was_created_by_proc;_force_writable($file);unlink1($self,$file)or unlink($file)}}sub tempfile {if (@_ && $_[0]eq 'File::Temp'){croak "'tempfile' can't be called as a method"}my%options=("DIR"=>undef,"SUFFIX"=>'',"UNLINK"=>0,"OPEN"=>1,"TMPDIR"=>0,"EXLOCK"=>0,"PERMS"=>undef,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (!$options{"OPEN"}){warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n" if $^W}if ($options{"DIR"}and $^O eq 'VMS'){$options{"DIR"}=VMS::Filespec::vmspath($options{"DIR"})}if (defined$template){if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catfile(_wrap_file_spec_tmpdir(),$template)}}else {if ($options{"DIR"}){$template=File::Spec->catfile($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catfile(_wrap_file_spec_tmpdir(),TEMPXXX)}}$template .= $options{"SUFFIX"};my$unlink_on_close=(wantarray ? 0 : 1);my ($fh,$path,$errstr);croak "Error in tempfile() using template $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>$options{OPEN},"mkdir"=>0,"unlink_on_close"=>$unlink_on_close,"suffixlen"=>length($options{SUFFIX}),"ErrStr"=>\$errstr,"use_exlock"=>$options{EXLOCK},"file_permissions"=>$options{PERMS},));_deferred_unlink($fh,$path,0)if$options{"UNLINK"};if (wantarray()){if ($options{'OPEN'}){return ($fh,$path)}else {return (undef,$path)}}else {unlink0($fh,$path)or croak "Error unlinking file $path using unlink0";return$fh}}{my ($alt_tmpdir,$checked);sub _wrap_file_spec_tmpdir {return File::Spec->tmpdir unless $^O eq "MSWin32" && ${^TAINT};if ($checked){return$alt_tmpdir ? $alt_tmpdir : File::Spec->tmpdir}my$xxpath=_replace_XX("X" x 10,0);my$tmpdir=File::Spec->tmpdir;my$testpath=File::Spec->catdir($tmpdir,$xxpath);if (mkdir($testpath,0700)){$checked=1;rmdir$testpath;return$tmpdir}require Win32;my$local_app=File::Spec->catdir(Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA()),'Temp');$testpath=File::Spec->catdir($local_app,$xxpath);if (-e $local_app or mkdir($local_app,0700)){if (mkdir($testpath,0700)){$checked=1;rmdir$testpath;return$alt_tmpdir=$local_app}}croak << "HERE"}}sub tempdir {if (@_ && $_[0]eq 'File::Temp'){croak "'tempdir' can't be called as a method"}my%options=("CLEANUP"=>0,"DIR"=>'',"TMPDIR"=>0,);my ($maybe_template,$args)=_parse_args(@_);my$template=@$maybe_template ? $maybe_template->[0]: undef;%options=(%options,%$args);if (defined$template){if ($options{'TMPDIR'}|| $options{'DIR'}){$template=VMS::Filespec::vmspath($template)if $^O eq 'VMS';my ($volume,$directories,undef)=File::Spec->splitpath($template,1);$template=(File::Spec->splitdir($directories))[-1];if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},$template)}elsif ($options{TMPDIR}){$template=File::Spec->catdir(_wrap_file_spec_tmpdir(),$template)}}}else {if ($options{"DIR"}){$template=File::Spec->catdir($options{"DIR"},TEMPXXX)}else {$template=File::Spec->catdir(_wrap_file_spec_tmpdir(),TEMPXXX)}}my$tempdir;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my$errstr;croak "Error in tempdir() using $template: $errstr" unless ((undef,$tempdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));if ($options{'CLEANUP'}&& -d $tempdir){_deferred_unlink(undef,$tempdir,1)}return$tempdir}sub mkstemp {croak "Usage: mkstemp(template)" if scalar(@_)!=1;my$template=shift;my ($fh,$path,$errstr);croak "Error in mkstemp using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkstemps {croak "Usage: mkstemps(template, suffix)" if scalar(@_)!=2;my$template=shift;my$suffix=shift;$template .= $suffix;my ($fh,$path,$errstr);croak "Error in mkstemps using $template: $errstr" unless (($fh,$path)=_gettemp($template,"open"=>1,"mkdir"=>0,"suffixlen"=>length($suffix),"ErrStr"=>\$errstr,));if (wantarray()){return ($fh,$path)}else {return$fh}}sub mkdtemp {croak "Usage: mkdtemp(template)" if scalar(@_)!=1;my$template=shift;my$suffixlen=0;if ($^O eq 'VMS'){$template =~ m/([\.\]:>]+)$/;$suffixlen=length($1)}if (($^O eq 'MacOS')&& (substr($template,-1)eq ':')){++$suffixlen}my ($junk,$tmpdir,$errstr);croak "Error creating temp directory from template $template\: $errstr" unless (($junk,$tmpdir)=_gettemp($template,"open"=>0,"mkdir"=>1,"suffixlen"=>$suffixlen,"ErrStr"=>\$errstr,));return$tmpdir}sub mktemp {croak "Usage: mktemp(template)" if scalar(@_)!=1;my$template=shift;my ($tmpname,$junk,$errstr);croak "Error getting name to temp file from template $template: $errstr" unless (($junk,$tmpname)=_gettemp($template,"open"=>0,"mkdir"=>0,"suffixlen"=>0,"ErrStr"=>\$errstr,));return$tmpname}sub tmpnam {my$tmpdir=_wrap_file_spec_tmpdir();croak "Error temporary directory is not writable" if$tmpdir eq '';my$template=File::Spec->catfile($tmpdir,TEMPXXX);if (wantarray()){return mkstemp($template)}else {return mktemp($template)}}sub tmpfile {my ($fh,$file)=tmpnam();unlink0($fh,$file)or return undef;return$fh}sub tempnam {croak 'Usage tempnam($dir, $prefix)' unless scalar(@_)==2;my ($dir,$prefix)=@_;$prefix .= 'XXXXXXXX';my$template=File::Spec->catfile($dir,$prefix);return mktemp($template)}sub unlink0 {croak 'Usage: unlink0(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;if (_can_unlink_opened_file()){return 1 if$KEEP_ALL;croak "unlink0: $path has become a directory!" if -d $path;unlink($path)or return 0;my@fh=stat$fh;print "Link count = $fh[3] \n" if$DEBUG;return 1 if$fh[3]==0 || $^O eq 'cygwin'}_deferred_unlink($fh,$path,0);return 1}sub cmpstat {croak 'Usage: cmpstat(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;warn "Comparing stat\n" if$DEBUG;my@fh;{local ($^W)=0;@fh=stat$fh}return unless@fh;if ($fh[3]> 1 && $^W){carp "unlink0: fstat found too many links; SB=@fh" if $^W}my@path=stat$path;unless (@path){carp "unlink0: $path is gone already" if $^W;return}unless (-f $path){confess "panic: $path is no longer a file: SB=@fh"}my@okstat=(0..$#fh);if ($^O eq 'MSWin32'){@okstat=(1,2,3,4,5,7,8,9,10)}elsif ($^O eq 'os2'){@okstat=(0,2..$#fh)}elsif ($^O eq 'VMS'){@okstat=(0,1)}elsif ($^O eq 'dos'){@okstat=(0,2..7,11..$#fh)}elsif ($^O eq 'mpeix'){@okstat=(0..4,8..10)}for (@okstat){print "Comparing: $_ : $fh[$_] and $path[$_]\n" if$DEBUG;unless ($fh[$_]eq $path[$_]){warn "Did not match $_ element of stat\n" if$DEBUG;return 0}}return 1}sub unlink1 {croak 'Usage: unlink1(filehandle, filename)' unless scalar(@_)==2;my ($fh,$path)=@_;cmpstat($fh,$path)or return 0;close($fh)or return 0;_force_writable($path);return 1 if$KEEP_ALL;return unlink($path)}{my$LEVEL=STANDARD;sub safe_level {my$self=shift;if (@_){my$level=shift;if (($level!=STANDARD)&& ($level!=MEDIUM)&& ($level!=HIGH)){carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W}else {if ($] < 5.006 && $level!=STANDARD){croak "Currently requires perl 5.006 or newer to do the safe checks"}$LEVEL=$level if _can_do_level($level)}}return$LEVEL}}{my$TopSystemUID=10;$TopSystemUID=197108 if $^O eq 'interix';sub top_system_uid {my$self=shift;if (@_){my$newuid=shift;croak "top_system_uid: UIDs should be numeric" unless$newuid =~ /^\d+$/s;$TopSystemUID=$newuid}return$TopSystemUID}}package File::Temp::Dir;our$VERSION='0.2311';use File::Path qw/rmtree/;use strict;use overload '""'=>"STRINGIFY",'0+'=>\&File::Temp::NUMIFY,fallback=>1;sub dirname {my$self=shift;return$self->{DIRNAME}}sub STRINGIFY {my$self=shift;return$self->dirname}sub unlink_on_destroy {my$self=shift;if (@_){$self->{CLEANUP}=shift}return$self->{CLEANUP}}sub DESTROY {my$self=shift;local($.,$@,$!,$^E,$?);if ($self->unlink_on_destroy && $$==$self->{LAUNCHPID}&&!$File::Temp::KEEP_ALL){if (-d $self->{REALNAME}){eval {rmtree($self->{REALNAME},$File::Temp::DEBUG,0)};warn $@ if ($@ && $^W)}}}1;
  Couldn't find a writable temp directory in taint mode. Tried:
    $tmpdir
    $local_app
  
  Try setting and untainting the TMPDIR environment variable.
  HERE
FILE_TEMP

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use base qw(Exporter);use File::Spec ();our$VERSION='1.27';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split /;/,$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split /;/,$ENV{PATH};s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"GitHub/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GITHUB_RELEASE';
  package GitHub::Release;use strict;use warnings;our$VERSION='0.001';use HTTP::Tinyish 0.18;sub new {my$class=shift;bless {http=>HTTP::Tinyish->new(verify_SSL=>1),http_no_redirect=>HTTP::Tinyish->new(verify_SSL=>1,max_redirect=>0),},$class}sub get_latest_tag {my ($self,$url)=@_;$url="$url/releases/latest";my$res=$self->{http_no_redirect}->get($url);if ($res->{status}!~ /^3/){die "$res->{status}, $url\n"}my$loc=$res->{headers}{location};(split /\//,$loc)[-1]}sub get_latest_assets {my ($self,$url)=@_;my$latest_tag=$self->get_latest_tag($url);$url="$url/releases/expanded_assets/$latest_tag";my$res=$self->{http}->get($url);if (!$res->{success}){die "$res->{status}, $url\n"}my@href=$res->{content}=~ m{ href="(.+?)" }xgi;map {m{^https} ? $_ : "https://github.com$_"}grep {m{/releases/download/}}@href}1;
GITHUB_RELEASE

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.088';sub _croak {require Carp;Carp::croak(@_)}my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{handle}){$self->{handle}->timeout($timeout)}}return$self->{timeout}}sub new {my($class,%args)=@_;if (exists$args{verify_ssl}){$args{verify_SSL}||= $args{verify_ssl}}my$self={max_redirect=>5,timeout=>defined$args{timeout}? $args{timeout}: 60,keep_alive=>1,verify_SSL=>defined$args{verify_SSL}? $args{verify_SSL}: _verify_SSL_default(),no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _verify_SSL_default {my ($self)=@_;return (($ENV{PERL_HTTP_TINY_SSL_INSECURE_BY_DEFAULT}|| '')eq '1')? 0 : 1}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}=($ENV{CGI_HTTP_PROXY}|| "")if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post patch delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (exists$args->{headers}){my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}$args->{headers}=$headers}if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or _croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end|SSL read error)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){$e->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}|| []};return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,},(@{$args->{_redirects}|| []}? (redirects=>delete$args->{_redirects}): ()),}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or _croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or _croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);_croak("form data keys must not be undef")if!defined($key);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');local@INC=@INC;pop@INC if$INC[-1]eq '.';unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}sub connected {my ($self)=@_;if ($self->{handle}){return$self->{handle}->connected}return}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;my$version=$class->VERSION;$default_agent .= "/$version" if defined$version;return$default_agent}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);if ($scheme ne 'http' && $scheme ne 'https'){die(qq/Unsupported URL scheme '$scheme'\n/)}my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$peer=$args->{peer}|| $host;if ('CODE' eq ref$peer){$peer=$peer->($host)}my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port,$peer)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port,$peer);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};my@redir_args=$self->_maybe_redirect($request,$response,$args);my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$cb_args=@redir_args ? +{}: $args;my$data_cb=$self->_prepare_data_cb($response,$cb_args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $handle->connected && $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;if (@redir_args){push @{$args->{_redirects}},$response;return$self->_request(@redir_args,$args)}$response->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}};return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port,$peer)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port,$peer)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){_croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){_croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {_croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port,$p_host);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){_croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v;$request->{header_case}{lc$k}=$k}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if ($request->{method}eq 'PUT' || $request->{method}eq 'POST'){if (!defined($args->{content})||!length($args->{content})){$request->{headers}{'content-length'}=0}}if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){if (exists$request->{'content-length'}&& $request->{'content-length'}==0){$request->{cb}=sub {""}}else {$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless exists$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){_croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});$args->{_redirects}||= [];if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and @{$args->{_redirects}}< $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;return "" if!defined$str;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/g;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];use Socket qw[SOL_SOCKET SO_KEEPALIVE];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.32)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;my$Field_Content=qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>HTTP::Tiny::_verify_SSL_default(),SSL_options=>{},%args },$class}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{fh}&& $self->{fh}->can('timeout')){$self->{fh}->timeout($timeout)}}return$self->{timeout}}sub connect {@_==5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ ."\n");my ($self,$scheme,$host,$port,$peer)=@_;if ($scheme eq 'https'){$self->_assert_ssl}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$peer,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},)or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);if ($self->{keep_alive}){unless (defined($self->{fh}->setsockopt(SOL_SOCKET,SO_KEEPALIVE,1))){CORE::close($self->{fh});die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/)}}$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{peer}=$peer;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub connected {my ($self)=@_;if ($self->{fh}&& $self->{fh}->connected){return wantarray ? ($self->{fh}->peerhost,$self->{fh}->peerport): join(':',$self->{fh}->peerhost,$self->{fh}->peerport)}return}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}local$SIG{PIPE}='IGNORE';while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers header_case/});$self->write_body($request)if$request->{cb};return}my@rfc_request_headers=qw(Accept Accept-Charset Accept-Encoding Accept-Language Authorization Cache-Control Connection Content-Length Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer Transfer-Encoding Upgrade User-Agent Via);my@other_request_headers=qw(Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin X-XSS-Protection);my%HeaderCase=map {lc($_)=>$_}@rfc_request_headers,@other_request_headers;sub write_header_lines {(@_ >= 2 && @_ <= 4 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ ."\n");my($self,$headers,$header_case,$prefix_data)=@_;$header_case ||= {};my$buf=(defined$prefix_data ? $prefix_data : '');my%seen;for my$k (qw/host cache-control expect max-forwards pragma range te/){next unless exists$headers->{$k};$seen{$k}++;my$field_name=$HeaderCase{$k};my$v=$headers->{$k};for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}while (my ($k,$v)=each %$headers){my$field_name=lc$k;next if$seen{$field_name};if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {if (exists$header_case->{$field_name}){$field_name=$header_case->{$field_name}}else {$field_name =~ s/\b(\w)/\u$1/g}$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){s/\x0D?\x0A\s+/ /g;die(qq/Invalid HTTP header field value ($field_name): / .$Printable->($_)."\n")unless $_ eq '' || /\A $Field_Content \z/xo;$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if (exists$request->{headers}{'content-length'}){return unless$request->{headers}{'content-length'};return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");if (ref$request->{trailer_cb}eq 'CODE'){$self->write_header_lines($request->{trailer_cb}->())}else {$self->write("\x0D\x0A")}return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) (?: [\x09\x20]+ ([^\x0D\x0A]*) )? \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);$reason="" unless defined$reason;die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ ."\n");my ($self,$method,$request_uri,$headers,$header_case)=@_;return$self->write_header_lines($headers,$header_case,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port,$peer)=@_;return 0 if$self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| $peer ne $self->{peer}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();my$ca_file=defined($self->{SSL_options}->{SSL_ca_file})? $self->{SSL_options}->{SSL_ca_file}: $ENV{SSL_CERT_FILE};if (defined$ca_file){unless (-r $ca_file){die qq/SSL_ca_file '$ca_file' not found or not readable\n/}return$ca_file}local@INC=@INC;pop@INC if$INC[-1]eq '.';return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.18';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror patch/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete patch/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--silent','--show-error','--max-time',($self->{timeout}|| 60),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if (my$max_redirect=exists$self->{max_redirect}? $self->{max_redirect}: 5){push@options,'--location','--max-redirs',$max_redirect}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(exists$attr{max_redirect}? $attr{max_redirect}: 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',(exists$self->{max_redirect}? $self->{max_redirect}: 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.008;use strict;use Exporter ();BEGIN {our@ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();use Scalar::Util qw(blessed reftype refaddr);our$VERSION='4.16';our@EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;use constant CORE_BOOL=>defined&builtin::is_bool;my$invalid_char_re;BEGIN {$invalid_char_re="[";for my$i (0 .. 0x01F,0x22,0x5c){$invalid_char_re .= quotemeta chr utf8::unicode_to_native($i)}$invalid_char_re=qr/$invalid_char_re]/}BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;if (CORE_BOOL){BEGIN {CORE_BOOL and warnings->unimport(qw(experimental::builtin))}if (builtin::is_bool($true)&& builtin::is_bool($false)&& $true &&!$false){$self->{core_bools}=!!1}else {delete$self->{core_bools}}}}else {delete$self->{false};delete$self->{true};delete$self->{core_bools}}return$self}sub core_bools {my$self=shift;my$core_bools=defined $_[0]? $_[0]: 1;if ($core_bools){$self->{true}=!!1;$self->{false}=!!0;$self->{core_bools}=!!1}else {$self->{true}=$JSON::PP::true;$self->{false}=$JSON::PP::false;$self->{core_bools}=!!0}return$self}sub get_core_bools {my$self=shift;return!!$self->{core_bools}}sub unblessed_bool {my$self=shift;return$self->core_bools(@_)}sub get_unblessed_bool {my$self=shift;return$self->get_core_bools(@_)}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){BEGIN {CORE_BOOL and warnings->unimport('experimental::builtin')}if (CORE_BOOL && builtin::is_bool($value)){return$value ? 'true' : 'false'}elsif (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/(["\\\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([^\n\t\c?[:^cntrl:][:^ascii:]])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=_encode_ascii($arg)}if ($latin1){$arg=_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {chr($_)=~ /[[:ascii:]]/ ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\b",t=>"\t",n=>"\n",f=>"\f",r=>"\r",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s",$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= _decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}my$hex=hex($u);if (chr$u =~ /[[:^ascii:]]/){$is_utf8=1;$s .= _decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if ($ch =~ /[[:^ascii:]]/){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ $invalid_char_re){if (!$relaxed or $ch ne "\t"){$at--;decode_error(sprintf "invalid character 0x%X" ." encountered while parsing JSON string",ord$ch)}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[\$\w[:^ascii:]]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}my$max_unicode_length=do {no warnings 'utf8';chr 0x10FFFF};utf8::encode($max_unicode_length);$max_unicode_length=length$max_unicode_length;sub is_valid_utf8 {my$start_point=substr($text,$at - 1);my$limit=$max_unicode_length;$limit=length($start_point)if$limit > length($start_point);while ($limit > 0){my$copy=substr($start_point,0,$limit);if (utf8::decode($copy)){$copy=substr($copy,0,1);utf8::encode($copy);$utf8_len=length$copy;return substr($start_point,0,$utf8_len)}$limit--}$utf8_len=0;return}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';for my$c (unpack($type,$str)){my$chr_c=chr($c);$mess .= $chr_c eq '\\' ? '\\\\' : $chr_c =~ /[[:print:]]/ ? $chr_c : $chr_c eq '\a' ? '\a' : $chr_c eq '\t' ? '\t' : $chr_c eq '\n' ? '\n' : $chr_c eq '\r' ? '\r' : $chr_c eq '\f' ? '\f' : sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}sub incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}sub incr_text : lvalue {$_[0]->{_incr_parser}||= JSON::PP::IncrParser->new;if ($_[0]->{_incr_parser}->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{_incr_parser}->{incr_text}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {if (blessed $_[0]){return ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}elsif (CORE_BOOL){BEGIN {CORE_BOOL and warnings->unimport('experimental::builtin')}return builtin::is_bool($_[0])}return!!0}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;our$VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}unless ($coder->get_utf8){utf8::decode($self->{incr_text})}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> ord " "){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){last INCR_PARSE if$p >= $len && $self->{incr_nest};while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){last INCR_PARSE if$p >= $len && $self->{incr_nest};while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s =~ /^[\t\n\r ]$/){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;use warnings;use overload ();overload::unimport('overload',qw(0+ ++ -- fallback));overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);our$VERSION='4.16';1;
JSON_PP_BOOLEAN

$fatpacked{"Parallel/Pipes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARALLEL_PIPES';
  package Parallel::Pipes;use 5.008001;use strict;use warnings;use IO::Handle;use IO::Select;use constant WIN32=>$^O eq 'MSWin32';our$VERSION='0.200';{package Parallel::Pipes::Impl;use Storable ();sub new {my ($class,%option)=@_;my$read_fh=delete$option{read_fh}or die;my$write_fh=delete$option{write_fh}or die;$write_fh->autoflush(1);bless {%option,read_fh=>$read_fh,write_fh=>$write_fh,buf=>'' },$class}sub read :method {my$self=shift;my$_size=$self->_read(4)or return;my$size=unpack 'I',$_size;my$freezed=$self->_read($size);Storable::thaw($freezed)}sub write :method {my ($self,$data)=@_;my$freezed=Storable::freeze({data=>$data});my$size=pack 'I',length($freezed);$self->_write("$size$freezed")}sub _read {my ($self,$size)=@_;my$fh=$self->{read_fh};my$offset=length$self->{buf};while ($offset < $size){my$len=sysread$fh,$self->{buf},65536,$offset;if (!defined$len){die $!}elsif ($len==0){last}else {$offset += $len}}return substr$self->{buf},0,$size,''}sub _write {my ($self,$data)=@_;my$fh=$self->{write_fh};my$size=length$data;my$offset=0;while ($size){my$len=syswrite$fh,$data,$size,$offset;if (!defined$len){die $!}elsif ($len==0){last}else {$size -= $len;$offset += $len}}$size}}{package Parallel::Pipes::Here;our@ISA=qw(Parallel::Pipes::Impl);use Carp ();sub new {my ($class,%option)=@_;$class->SUPER::new(%option,_written=>0)}sub is_written {my$self=shift;$self->{_written}==1}sub read :method {my$self=shift;if (!$self->is_written){Carp::croak("This pipe has not been written; you cannot read it")}$self->{_written}--;return unless my$read=$self->SUPER::read;$read->{data}}sub write :method {my ($self,$task)=@_;if ($self->is_written){Carp::croak("This pipe has already been written; you must read it first")}$self->{_written}++;$self->SUPER::write($task)}}{package Parallel::Pipes::There;our@ISA=qw(Parallel::Pipes::Impl)}{package Parallel::Pipes::Impl::NoFork;use Carp ();sub new {my ($class,%option)=@_;bless {%option},$class}sub is_written {my$self=shift;exists$self->{_result}}sub read :method {my$self=shift;if (!$self->is_written){Carp::croak("This pipe has not been written; you cannot read it")}delete$self->{_result}}sub write :method {my ($self,$task)=@_;if ($self->is_written){Carp::croak("This pipe has already been written; you must read it first")}my$result=$self->{work}->($task);$self->{_result}=$result}}sub new {my ($class,$number,$work,$option)=@_;if (WIN32 and $number!=1){die "The number of pipes must be 1 under WIN32 environment.\n"}my$self=bless {work=>$work,number=>$number,no_fork=>$number==1,pipes=>{},option=>$option || {},},$class;if ($self->no_fork){$self->{pipes}{-1}=Parallel::Pipes::Impl::NoFork->new(pid=>-1,work=>$self->{work})}else {$self->_fork for 1 .. $number}$self}sub no_fork {shift->{no_fork}}sub _fork {my$self=shift;my$work=$self->{work};pipe my$read_fh1,my$write_fh1;pipe my$read_fh2,my$write_fh2;my$pid=fork;die "fork failed" unless defined$pid;if ($pid==0){srand;close $_ for$read_fh1,$write_fh2,map {($_->{read_fh},$_->{write_fh})}$self->pipes;my$there=Parallel::Pipes::There->new(read_fh=>$read_fh2,write_fh=>$write_fh1);while (my$read=$there->read){$there->write($work->($read->{data}))}exit}close $_ for$write_fh1,$read_fh2;$self->{pipes}{$pid}=Parallel::Pipes::Here->new(pid=>$pid,read_fh=>$read_fh1,write_fh=>$write_fh2,)}sub pipes {my$self=shift;map {$self->{pipes}{$_}}sort {$a <=> $b}keys %{$self->{pipes}}}sub is_ready {my$self=shift;return$self->pipes if$self->no_fork;my@pipes=@_ ? @_ : $self->pipes;if (my@ready=grep {$_->{_written}==0}@pipes){return@ready}my$select=IO::Select->new(map {$_->{read_fh}}@pipes);my@ready;if (my$tick=$self->{option}{idle_tick}){while (1){if (my@r=$select->can_read($tick)){@ready=@r,last}$self->{option}{idle_work}->()}}else {@ready=$select->can_read}my@return;for my$pipe (@pipes){if (grep {$pipe->{read_fh}==$_}@ready){push@return,$pipe}}return@return}sub is_written {my$self=shift;grep {$_->is_written}$self->pipes}sub close :method {my$self=shift;return if$self->no_fork;close $_ for map {($_->{write_fh},$_->{read_fh})}$self->pipes;while (%{$self->{pipes}}){my$pid=wait;if (delete$self->{pipes}{$pid}){}else {warn "wait() unexpectedly returns $pid\n"}}}1;
PARALLEL_PIPES

$fatpacked{"Parallel/Pipes/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARALLEL_PIPES_APP';
  package Parallel::Pipes::App;use strict;use warnings;use Parallel::Pipes;our$VERSION='0.200';sub _min {$_[0]< $_[1]? $_[0]: $_[1]}sub run {my ($class,%argv)=@_;my$work=$argv{work}or die "need 'work' argument\n";my$num=$argv{num}or die "need 'num' argument\n";my$tasks=$argv{tasks}or die "need 'tasks' argument\n";my$before_work=$argv{before_work};my$after_work=$argv{after_work};my$init_work=$argv{init_work};my$idle_tick=$argv{idle_tick};my$idle_work=$argv{idle_work};my$pipes=Parallel::Pipes->new($num,$work,$idle_tick ? {idle_tick=>$idle_tick,idle_work=>$idle_work }: (),);$init_work->($pipes)if$init_work;while (1){my@ready=$pipes->is_ready;if (my@written=grep {$_->is_written}@ready){for my$written (@written){my$result=$written->read;$after_work->($result,$written)if$after_work}}if (@$tasks){my$min=_min $#{$tasks},$#ready;for my$i (0 .. $min){my$task=shift @$tasks;$before_work->($task,$ready[$i])if$before_work;$ready[$i]->write($task)}}else {if (@ready==$num){last}else {if (my@written=$pipes->is_written){my@ready=$pipes->is_ready(@written);for my$written (@ready){my$result=$written->read;$after_work->($result,$written)if$after_work}}else {die "unexpected"}}}}$pipes->close;1}sub map :method {my ($class,%argv)=@_;my$orig_num=$argv{num}or die "need 'num' argument\n";my$orig_tasks=$argv{tasks}or die "need 'tasks' argument\n";my$orig_work=$argv{work}or die "need 'work' argument\n";my@task=map {[$_,$orig_tasks->[$_]]}0..$#{$orig_tasks};my$work=sub {my ($index,$task)=@{$_[0]};my$result=$orig_work->($task);[$index,$result]};my@result;my$after_work=sub {my ($index,$result)=@{$_[0]};$result[$index]=$result};$class->run(num=>$orig_num,work=>$work,tasks=>\@task,after_work=>$after_work);@result}1;
PARALLEL_PIPES_APP

$fatpacked{"YAML/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP';
  use strict;use warnings;package YAML::PP;our$VERSION='0.036';use YAML::PP::Schema;use YAML::PP::Schema::JSON;use YAML::PP::Loader;use YAML::PP::Dumper;use Scalar::Util qw/blessed/;use Carp qw/croak/;use base 'Exporter';our@EXPORT_OK=qw/Load LoadFile Dump DumpFile/;my%YAML_VERSIONS=('1.1'=>1,'1.2'=>1);sub new {my ($class,%args)=@_;my$bool=delete$args{boolean};$bool='perl' unless defined$bool;my$schemas=delete$args{schema}|| ['+'];my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$indent=delete$args{indent};my$width=delete$args{width};my$writer=delete$args{writer};my$header=delete$args{header};my$footer=delete$args{footer};my$duplicate_keys=delete$args{duplicate_keys};my$yaml_version=$class->_arg_yaml_version(delete$args{yaml_version});my$default_yaml_version=$yaml_version->[0];my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$parser=delete$args{parser};my$emitter=delete$args{emitter}|| {indent=>$indent,width=>$width,writer=>$writer,};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my%schemas;for my$v (@$yaml_version){my$schema;if (blessed($schemas)and $schemas->isa('YAML::PP::Schema')){$schema=$schemas}else {$schema=YAML::PP::Schema->new(boolean=>$bool,yaml_version=>$v,);$schema->load_subschemas(@$schemas)}$schemas{$v }=$schema}my$default_schema=$schemas{$default_yaml_version };my$loader=YAML::PP::Loader->new(schemas=>\%schemas,cyclic_refs=>$cyclic_refs,parser=>$parser,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$dumper=YAML::PP::Dumper->new(schema=>$default_schema,emitter=>$emitter,header=>$header,footer=>$footer,version_directive=>$version_directive,preserve=>$preserve,);my$self=bless {schema=>\%schemas,loader=>$loader,dumper=>$dumper,},$class;return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,loader=>$self->loader->clone,dumper=>$self->dumper->clone,};return bless$clone,ref$self}sub _arg_yaml_version {my ($class,$version)=@_;my@versions=('1.2');if (defined$version){@versions=();if (not ref$version){$version=[$version]}for my$v (@$version){unless ($YAML_VERSIONS{$v }){croak "YAML Version '$v' not supported"}push@versions,$v}}return \@versions}sub loader {if (@_ > 1){$_[0]->{loader}=$_[1]}return $_[0]->{loader}}sub dumper {if (@_ > 1){$_[0]->{dumper}=$_[1]}return $_[0]->{dumper}}sub schema {if (@_ > 1){$_[0]->{schema}->{'1.2'}=$_[1]}return $_[0]->{schema}->{'1.2'}}sub default_schema {my ($self,%args)=@_;my$schema=YAML::PP::Schema->new(boolean=>$args{boolean},);$schema->load_subschemas(qw/Core/);return$schema}sub load_string {my ($self,$yaml)=@_;return$self->loader->load_string($yaml)}sub load_file {my ($self,$file)=@_;return$self->loader->load_file($file)}sub dump {my ($self,@data)=@_;return$self->dumper->dump(@data)}sub dump_string {my ($self,@data)=@_;return$self->dumper->dump_string(@data)}sub dump_file {my ($self,$file,@data)=@_;return$self->dumper->dump_file($file,@data)}sub Load {my ($yaml)=@_;YAML::PP->new->load_string($yaml)}sub LoadFile {my ($file)=@_;YAML::PP->new->load_file($file)}sub Dump {my (@data)=@_;YAML::PP->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;YAML::PP->new->dump_file($file,@data)}sub preserved_scalar {my ($self,$value,%args)=@_;my$scalar=YAML::PP::Preserve::Scalar->new(value=>$value,%args,);return$scalar}sub preserved_mapping {my ($self,$hash,%args)=@_;my$data={};tie %$data,'YAML::PP::Preserve::Hash';%$data=%$hash;my$t=tied %$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}sub preserved_sequence {my ($self,$array,%args)=@_;my$data=[];tie @$data,'YAML::PP::Preserve::Array';push @$data,@$array;my$t=tied @$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}package YAML::PP::Preserve::Hash;use Tie::Hash;use base qw/Tie::StdHash/;use Scalar::Util qw/reftype blessed/;sub TIEHASH {my ($class,%args)=@_;my$self=bless {keys=>[keys%args],data=>{%args },},$class}sub STORE {my ($self,$key,$val)=@_;my$keys=$self->{keys};unless (exists$self->{data}->{$key }){push @$keys,$key}if (ref$val and not blessed($val)){if (reftype($val)eq 'HASH' and not tied %$val){tie %$val,'YAML::PP::Preserve::Hash',%$val}elsif (reftype($val)eq 'ARRAY' and not tied @$val){tie @$val,'YAML::PP::Preserve::Array',@$val}}$self->{data}->{$key }=$val}sub FIRSTKEY {my ($self)=@_;return$self->{keys}->[0]}sub NEXTKEY {my ($self,$last)=@_;my$keys=$self->{keys};for my$i (0 .. $#$keys){if ("$keys->[ $i ]" eq "$last"){return$keys->[$i + 1 ]}}return}sub FETCH {my ($self,$key)=@_;my$val=$self->{data}->{$key }}sub DELETE {my ($self,$key)=@_;@{$self->{keys}}=grep {"$_" ne "$key"}@{$self->{keys}};delete$self->{data}->{$key }}sub EXISTS {my ($self,$key)=@_;return exists$self->{data}->{$key }}sub CLEAR {my ($self)=@_;$self->{keys}=[];$self->{data}={}}sub SCALAR {my ($self)=@_;return scalar %{$self->{data}}}package YAML::PP::Preserve::Array;use Tie::Array;use base qw/Tie::StdArray/;use Scalar::Util qw/reftype blessed/;sub TIEARRAY {my ($class,@items)=@_;my$self=bless {data=>[@items],},$class;return$self}sub FETCH {my ($self,$i)=@_;return$self->{data}->[$i ]}sub FETCHSIZE {my ($self)=@_;return $#{$self->{data}}+ 1}sub _preserve {my ($val)=@_;if (ref$val and not blessed($val)){if (reftype($val)eq 'HASH' and not tied %$val){tie %$val,'YAML::PP::Preserve::Hash',%$val}elsif (reftype($val)eq 'ARRAY' and not tied @$val){tie @$val,'YAML::PP::Preserve::Array',@$val}}return$val}sub STORE {my ($self,$i,$val)=@_;_preserve($val);$self->{data}->[$i ]=$val}sub PUSH {my ($self,@args)=@_;push @{$self->{data}},map {_preserve $_}@args}sub STORESIZE {my ($self,$i)=@_;$#{$self->{data}}=$i - 1}sub DELETE {my ($self,$i)=@_;delete$self->{data}->[$i ]}sub EXISTS {my ($self,$i)=@_;return exists$self->{data}->[$i ]}sub CLEAR {my ($self)=@_;$self->{data}=[]}sub SHIFT {my ($self)=@_;shift @{$self->{data}}}sub UNSHIFT {my ($self,@args)=@_;unshift @{$self->{data}},map {_preserve $_}@args}sub SPLICE {my ($self,$offset,$length,@args)=@_;splice @{$self->{data}},$offset,$length,map {_preserve $_}@args}sub EXTEND {}package YAML::PP::Preserve::Scalar;use overload fallback=>1,'+'=>\&value,'""'=>\&value,'bool'=>\&value,;sub new {my ($class,%args)=@_;my$self={%args,};bless$self,$class}sub value {$_[0]->{value}}sub tag {$_[0]->{tag}}sub style {$_[0]->{style}|| 0}sub alias {$_[0]->{alias}}1;
YAML_PP

$fatpacked{"YAML/PP/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_COMMON';
  use strict;use warnings;package YAML::PP::Common;our$VERSION='0.036';use base 'Exporter';my@p=qw/PRESERVE_ALL PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;my@s=qw/YAML_ANY_SCALAR_STYLE YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_QUOTED_SCALAR_STYLE YAML_ANY_SEQUENCE_STYLE YAML_BLOCK_SEQUENCE_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_ANY_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_FLOW_MAPPING_STYLE/;our@EXPORT_OK=(@s,@p);our%EXPORT_TAGS=(PRESERVE=>[@p],STYLES=>[@s],);use constant {YAML_ANY_SCALAR_STYLE=>0,YAML_PLAIN_SCALAR_STYLE=>1,YAML_SINGLE_QUOTED_SCALAR_STYLE=>2,YAML_DOUBLE_QUOTED_SCALAR_STYLE=>3,YAML_LITERAL_SCALAR_STYLE=>4,YAML_FOLDED_SCALAR_STYLE=>5,YAML_QUOTED_SCALAR_STYLE=>'Q',YAML_ANY_SEQUENCE_STYLE=>0,YAML_BLOCK_SEQUENCE_STYLE=>1,YAML_FLOW_SEQUENCE_STYLE=>2,YAML_ANY_MAPPING_STYLE=>0,YAML_BLOCK_MAPPING_STYLE=>1,YAML_FLOW_MAPPING_STYLE=>2,PRESERVE_ORDER=>2,PRESERVE_SCALAR_STYLE=>4,PRESERVE_FLOW_STYLE=>8,PRESERVE_ALIAS=>16,PRESERVE_ALL=>31,};my%scalar_style_to_string=(YAML_PLAIN_SCALAR_STYLE()=>':',YAML_SINGLE_QUOTED_SCALAR_STYLE()=>"'",YAML_DOUBLE_QUOTED_SCALAR_STYLE()=>'"',YAML_LITERAL_SCALAR_STYLE()=>'|',YAML_FOLDED_SCALAR_STYLE()=>'>',);sub event_to_test_suite {my ($event,$args)=@_;my$ev=$event->{name};my$string;my$content=$event->{value};my$properties='';$properties .= " &$event->{anchor}" if defined$event->{anchor};$properties .= " <$event->{tag}>" if defined$event->{tag};if ($ev eq 'document_start_event'){$string="+DOC";$string .= " ---" unless$event->{implicit}}elsif ($ev eq 'document_end_event'){$string="-DOC";$string .= " ..." unless$event->{implicit}}elsif ($ev eq 'stream_start_event'){$string="+STR"}elsif ($ev eq 'stream_end_event'){$string="-STR"}elsif ($ev eq 'mapping_start_event'){$string="+MAP";if ($event->{style}and $event->{style}eq YAML_FLOW_MAPPING_STYLE){$string .= ' {}' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'sequence_start_event'){$string="+SEQ";if ($event->{style}and $event->{style}eq YAML_FLOW_SEQUENCE_STYLE){$string .= ' []' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'mapping_end_event'){$string="-MAP"}elsif ($ev eq 'sequence_end_event'){$string="-SEQ"}elsif ($ev eq 'scalar_event'){$string='=VAL';$string .= $properties;$content =~ s/\\/\\\\/g;$content =~ s/\t/\\t/g;$content =~ s/\r/\\r/g;$content =~ s/\n/\\n/g;$content =~ s/[\b]/\\b/g;$string .= ' ' .$scalar_style_to_string{$event->{style}}.$content}elsif ($ev eq 'alias_event'){$string="=ALI *$content"}return$string}sub test_suite_to_event {my ($str)=@_;my$event={};if ($str =~ s/^\+STR//){$event->{name}='stream_start_event'}elsif ($str =~ s/^\-STR//){$event->{name}='stream_end_event'}elsif ($str =~ s/^\+DOC//){$event->{name}='document_start_event';if ($str =~ s/^ ---//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\-DOC//){$event->{name}='document_end_event';if ($str =~ s/^ \.\.\.//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\+SEQ//){$event->{name}='sequence_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-SEQ//){$event->{name}='sequence_end_event'}elsif ($str =~ s/^\+MAP//){$event->{name}='mapping_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-MAP//){$event->{name}='mapping_end_event'}elsif ($str =~ s/^=VAL//){$event->{name}='scalar_event';if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}if ($str =~ s/^ [:'">|]//){$event->{style}=$1}if ($str =~ s/^(.*)//){$event->{value}=$1}}elsif ($str =~ s/^=ALI//){$event->{name}='alias_event';if ($str =~ s/^ \*(.*)//){$event->{value}=$1}}else {die "Could not parse event '$str'"}return$event}1;
YAML_PP_COMMON

$fatpacked{"YAML/PP/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_CONSTRUCTOR';
  use strict;use warnings;package YAML::PP::Constructor;our$VERSION='0.036';use YAML::PP;use YAML::PP::Common qw/PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use Scalar::Util qw/reftype/;use Carp qw/croak/;use constant DEBUG=>($ENV{YAML_PP_LOAD_DEBUG}or $ENV{YAML_PP_LOAD_TRACE})? 1 : 0;use constant TRACE=>$ENV{YAML_PP_LOAD_TRACE}? 1 : 0;my%cyclic_refs=qw/allow 1 ignore 1 warn 1 fatal 1/;sub new {my ($class,%args)=@_;my$default_yaml_version=delete$args{default_yaml_version};my$duplicate_keys=delete$args{duplicate_keys};unless (defined$duplicate_keys){$duplicate_keys=0}my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';die "Invalid value for cyclic_refs: $cyclic_refs" unless$cyclic_refs{$cyclic_refs };my$schemas=delete$args{schemas};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {default_yaml_version=>$default_yaml_version,schemas=>$schemas,cyclic_refs=>$cyclic_refs,preserve=>$preserve,duplicate_keys=>$duplicate_keys,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={schemas=>$self->{schemas},schema=>$self->{schema},default_yaml_version=>$self->{default_yaml_version},cyclic_refs=>$self->cyclic_refs,preserve=>$self->{preserve},};return bless$clone,ref$self}sub init {my ($self)=@_;$self->set_docs([]);$self->set_stack([]);$self->set_anchors({});$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->yaml_version })}sub docs {return $_[0]->{docs}}sub stack {return $_[0]->{stack}}sub anchors {return $_[0]->{anchors}}sub set_docs {$_[0]->{docs}=$_[1]}sub set_stack {$_[0]->{stack}=$_[1]}sub set_anchors {$_[0]->{anchors}=$_[1]}sub schemas {return $_[0]->{schemas}}sub schema {return $_[0]->{schema}}sub set_schema {$_[0]->{schema}=$_[1]}sub cyclic_refs {return $_[0]->{cyclic_refs}}sub set_cyclic_refs {$_[0]->{cyclic_refs}=$_[1]}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub duplicate_keys {return $_[0]->{duplicate_keys}}sub document_start_event {my ($self,$event)=@_;my$stack=$self->stack;if ($event->{version_directive}){my$version=$event->{version_directive};$version="$version->{major}.$version->{minor}";if ($self->{schemas}->{$version }){$self->set_yaml_version($version);$self->set_schema($self->schemas->{$version })}else {$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->default_yaml_version })}}my$ref=[];push @$stack,{type=>'document',ref=>$ref,data=>$ref,event=>$event }}sub document_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'document' or die "Expected mapping, but got $last->{type}";if (@$stack){die "Got unexpected end of document"}my$docs=$self->docs;push @$docs,$last->{ref}->[0];$self->set_anchors({});$self->set_stack([])}sub mapping_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_mapping($self,$event);my$ref={type=>'mapping',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_order=$self->preserve_order;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if (($preserve_order or $preserve_style or $preserve_alias)and not tied(%$data)){tie %$data,'YAML::PP::Preserve::Hash',%$data}if ($preserve_style){my$t=tied %$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied %$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub mapping_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;my ($ref,$data)=@{$last}{qw/ref data/};$last->{type}eq 'mapping' or die "Expected mapping, but got $last->{type}";my@merge_keys;my@ref;for (my$i=0;$i < @$ref;$i += 2){my$key=$ref->[$i ];if (ref$key eq 'YAML::PP::Type::MergeKey'){my$merge=$ref->[$i + 1 ];if ((reftype($merge)|| '')eq 'HASH'){push@merge_keys,$merge}elsif ((reftype($merge)|| '')eq 'ARRAY'){for my$item (@$merge){if ((reftype($item)|| '')eq 'HASH'){push@merge_keys,$item}else {die "Expected hash for merge key"}}}else {die "Expected hash or array for merge key"}}else {push@ref,$key,$ref->[$i + 1 ]}}for my$merge (@merge_keys){for my$key (keys %$merge){unless (exists $$data->{$key }){$$data->{$key }=$merge->{$key }}}}my$on_data=$last->{on_data}|| sub {my ($self,$hash,$items)=@_;my%seen;for (my$i=0;$i < @$items;$i += 2){my ($key,$value)=@$items[$i,$i + 1 ];$key='' unless defined$key;if (ref$key){$key=$self->stringify_complex($key)}if ($seen{$key }++ and not $self->duplicate_keys){croak "Duplicate key '$key'"}$$hash->{$key }=$value}};$on_data->($self,$data,\@ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){$self->anchors->{$anchor }->{finished}=1}return}sub sequence_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_sequence($self,$event);my$ref={type=>'sequence',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if ($preserve_style or $preserve_alias and not tied(@$data)){tie @$data,'YAML::PP::Preserve::Array',@$data;my$t=tied @$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied @$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub sequence_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'sequence' or die "Expected mapping, but got $last->{type}";my ($ref,$data)=@{$last}{qw/ref data/};my$on_data=$last->{on_data}|| sub {my ($self,$array,$items)=@_;push @$$array,@$items};$on_data->($self,$data,$ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){my$test=$self->anchors->{$anchor };$self->anchors->{$anchor }->{finished}=1}return}sub stream_start_event {}sub stream_end_event {}sub scalar_event {my ($self,$event)=@_;DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";my$value=$self->schema->load_scalar($self,$event);my$last=$self->stack->[-1];my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if (($preserve_style or $preserve_alias)and not ref$value){my%args=(value=>$value,tag=>$event->{tag},);if ($preserve_style){$args{style}=$event->{style}}if ($preserve_alias and defined$event->{anchor}){my$anchor=$event->{anchor};unless (exists$self->anchors->{$anchor }){$args{alias}=$event->{anchor}}}$value=YAML::PP::Preserve::Scalar->new(%args)}if (defined (my$name=$event->{anchor})){$self->anchors->{$name }={data=>\$value,finished=>1 }}push @{$last->{ref}},$value}sub alias_event {my ($self,$event)=@_;my$value;my$name=$event->{value};if (my$anchor=$self->anchors->{$name }){unless ($anchor->{finished}){my$cyclic_refs=$self->cyclic_refs;if ($cyclic_refs ne 'allow'){if ($cyclic_refs eq 'fatal'){die "Found cyclic ref for alias '$name'"}if ($cyclic_refs eq 'warn'){$anchor={data=>\undef };warn "Found cyclic ref for alias '$name'"}elsif ($cyclic_refs eq 'ignore'){$anchor={data=>\undef }}}}$value=$anchor->{data}}else {croak "No anchor defined for alias '$name'"}my$last=$self->stack->[-1];push @{$last->{ref}},$$value}sub stringify_complex {my ($self,$data)=@_;return$data if (ref$data eq 'YAML::PP::Preserve::Scalar' and ($self->preserve_scalar_style or $self->preserve_alias));require Data::Dumper;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=0;local$Data::Dumper::Sortkeys=1;my$string=Data::Dumper->Dump([$data],['data']);$string =~ s/^\$data = //;return$string}1;
YAML_PP_CONSTRUCTOR

$fatpacked{"YAML/PP/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_DUMPER';
  use strict;use warnings;package YAML::PP::Dumper;our$VERSION='0.036';use Scalar::Util qw/blessed refaddr reftype/;use YAML::PP;use YAML::PP::Emitter;use YAML::PP::Representer;use YAML::PP::Writer;use YAML::PP::Writer::File;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE/;sub new {my ($class,%args)=@_;my$header=delete$args{header};$header=1 unless defined$header;my$footer=delete$args{footer};$footer=0 unless defined$footer;my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$schema=delete$args{schema}|| YAML::PP->default_schema(boolean=>'perl',);my$emitter=delete$args{emitter}|| YAML::PP::Emitter->new;unless (blessed($emitter)){$emitter=YAML::PP::Emitter->new(%$emitter)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {representer=>YAML::PP::Representer->new(schema=>$schema,preserve=>$preserve,),version_directive=>$version_directive,emitter=>$emitter,seen=>{},anchors=>{},anchor_num=>0,header=>$header,footer=>$footer,},$class;return$self}sub clone {my ($self)=@_;my$clone={representer=>$self->representer->clone,emitter=>$self->emitter->clone,version_directive=>$self->version_directive,seen=>{},anchors=>{},anchor_num=>0,header=>$self->header,footer=>$self->footer,};return bless$clone,ref$self}sub init {my ($self)=@_;$self->{seen}={};$self->{anchors}={};$self->{anchor_num}=0}sub emitter {return $_[0]->{emitter}}sub representer {return $_[0]->{representer}}sub set_representer {$_[0]->{representer}=$_[1]}sub header {return $_[0]->{header}}sub footer {return $_[0]->{footer}}sub version_directive {return $_[0]->{version_directive}}sub dump {my ($self,@docs)=@_;$self->emitter->init;$self->emitter->stream_start_event({});for my$i (0 .. $#docs){my$header_implicit=($i==0 and not $self->header);my%args=(implicit=>$header_implicit,);if ($self->version_directive){my ($major,$minor)=split m/\./,$self->representer->schema->yaml_version;$args{version_directive}={major=>$major,minor=>$minor }}$self->emitter->document_start_event(\%args);$self->init;$self->_check_references($docs[$i ]);$self->_dump_node($docs[$i ]);my$footer_implicit=(not $self->footer);$self->emitter->document_end_event({implicit=>$footer_implicit })}$self->emitter->stream_end_event({});my$output=$self->emitter->writer->output;$self->emitter->finish;return$output}sub _dump_node {my ($self,$value)=@_;my$node={value=>$value,};if (ref$value){my$seen=$self->{seen};my$refaddr=refaddr$value;if ($seen->{$refaddr }and $seen->{$refaddr }> 1){my$anchor=$self->{anchors}->{$refaddr };unless (defined$anchor){if ($self->representer->preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){if (defined$node->{value}->alias){$node->{anchor}=$node->{value}->alias;$self->{anchors}->{$refaddr }=$node->{value}->alias}}elsif (reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}elsif (reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}}unless (defined$node->{anchor}){my$num= ++$self->{anchor_num};$self->{anchors}->{$refaddr }=$num;$node->{anchor}=$num}}else {$node->{value}=$anchor;$self->_emit_node([alias=>$node ]);return}}}$node=$self->representer->represent_node($node);$self->_emit_node($node)}sub _emit_node {my ($self,$item)=@_;my ($type,$node,%args)=@$item;if ($type eq 'alias'){$self->emitter->alias_event({value=>$node->{value}});return}if ($type eq 'mapping'){my$style=$args{style}|| YAML_BLOCK_MAPPING_STYLE;if ($node->{items}and @{$node->{items}}==0){}$self->emitter->mapping_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->_dump_node($_)}$self->emitter->mapping_end_event;return}if ($type eq 'sequence'){my$style=$args{style}|| YAML_BLOCK_SEQUENCE_STYLE;if (@{$node->{items}}==0){}$self->emitter->sequence_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->_dump_node($_)}$self->emitter->sequence_end_event;return}$self->emitter->scalar_event({value=>$node->{items}->[0],style=>$node->{style},anchor=>$node->{anchor},tag=>$node->{tag},})}sub dump_string {my ($self,@docs)=@_;my$writer=YAML::PP::Writer->new;$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}sub dump_file {my ($self,$file,@docs)=@_;my$writer=YAML::PP::Writer::File->new(output=>$file);$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}my%_reftypes=(HASH=>1,ARRAY=>1,Regexp=>1,REGEXP=>1,CODE=>1,SCALAR=>1,REF=>1,GLOB=>1,);sub _check_references {my ($self,$doc)=@_;my$reftype=reftype$doc or return;my$seen=$self->{seen};if ($reftype eq 'SCALAR' and grep {ref$doc eq $_}@{$self->representer->schema->bool_class || []}){if (ref$doc eq 'boolean' or ref$doc eq 'JSON::PP::Boolean'){return}}if (++$seen->{refaddr$doc }> 1){return}unless ($_reftypes{$reftype }){die sprintf "Reference %s not implemented",$reftype}if ($reftype eq 'HASH'){$self->_check_references($doc->{$_ })for keys %$doc}elsif ($reftype eq 'ARRAY'){$self->_check_references($_)for @$doc}elsif ($reftype eq 'REF'){$self->_check_references($$doc)}}1;
YAML_PP_DUMPER

$fatpacked{"YAML/PP/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EMITTER';
  use strict;use warnings;package YAML::PP::Emitter;our$VERSION='0.036';use Data::Dumper;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use constant DEBUG=>$ENV{YAML_PP_EMIT_DEBUG}? 1 : 0;use constant DEFAULT_WIDTH=>80;sub new {my ($class,%args)=@_;my$self=bless {indent=>$args{indent}|| 2,writer=>$args{writer},width=>$args{width}|| DEFAULT_WIDTH,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={indent=>$self->indent,};return bless$clone,ref$self}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub indent {return $_[0]->{indent}}sub width {return $_[0]->{width}}sub line {return $_[0]->{line}}sub column {return $_[0]->{column}}sub set_indent {$_[0]->{indent}=$_[1]}sub writer {$_[0]->{writer}}sub set_writer {$_[0]->{writer}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub init {my ($self)=@_;unless ($self->writer){$self->set_writer(YAML::PP::Writer->new)}$self->set_tagmap({'tag:yaml.org,2002:'=>'!!',});$self->{open_ended}=0;$self->{line}=0;$self->{column}=0;$self->writer->init}sub mapping_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->_emit_tag('map',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if ($info->{style}|| 0)eq YAML_FLOW_MAPPING_STYLE;my$newline=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$new_indent .= ' ' x $self->indent;$newline=1}else {$new_indent=$indent;if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= '-'}elsif ($last->{type}eq 'MAP'){$yaml .= "?";$last->{type}='COMPLEX'}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":"}else {die "Should not happen ($last->{type} in mapping_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);my$new_info={index=>0,indent=>$new_indent,info=>$info,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='MAP';push @{$stack},$new_info;$last->{index}++;$self->{open_ended}=0}sub mapping_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}if ($self->column){$self->_write(" {}\n")}else {$self->_write("$indent\{}\n")}}elsif ($last->{flow}){my$yaml="}";if ($last->{flow}==1){$yaml .= "\n"}$self->_write("$yaml")}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}sub sequence_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->_emit_tag('seq',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if$flow or ($info->{style}|| 0)eq YAML_FLOW_SEQUENCE_STYLE;my$newline=0;my$zero_indent=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$zero_indent=1;$newline=1}else {if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= "-"}elsif ($last->{type}eq 'MAP'){$last->{type}='COMPLEX';$zero_indent=1;$yaml .= "?"}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":";$zero_indent=1}else {die "Should not happen ($last->{type} in sequence_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);$last->{index}++;my$new_info={index=>0,indent=>$new_indent,info=>$info,zero_indent=>$zero_indent,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='SEQ';push @{$stack},$new_info;$self->{open_ended}=0}sub sequence_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}my$yaml .= $self->column ? ' ' : $indent;$yaml .= "[]";if ($last->{flow}< 2){$yaml .= "\n"}$self->_write($yaml)}elsif ($last->{flow}){my$yaml="]";if ($last->{flow}==1){$yaml .= "\n"}$self->_write($yaml)}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}my%forbidden_first=(qw/! 1 & 1 * 1 { 1 } 1 [ 1 ] 1 | 1 > 1 @ 1 ` 1 " 1 ' 1/,'#'=>1,'%'=>1,','=>1," "=>1);my%forbidden_first_plus_space=(qw/? 1 - 1 : 1/);my%control=("\x00"=>'\0',"\x01"=>'\x01',"\x02"=>'\x02',"\x03"=>'\x03',"\x04"=>'\x04',"\x05"=>'\x05',"\x06"=>'\x06',"\x07"=>'\a',"\x08"=>'\b',"\x0b"=>'\v',"\x0c"=>'\f',"\x0e"=>'\x0e',"\x0f"=>'\x0f',"\x10"=>'\x10',"\x11"=>'\x11',"\x12"=>'\x12',"\x13"=>'\x13',"\x14"=>'\x14',"\x15"=>'\x15',"\x16"=>'\x16',"\x17"=>'\x17',"\x18"=>'\x18',"\x19"=>'\x19',"\x1a"=>'\x1a',"\x1b"=>'\e',"\x1c"=>'\x1c',"\x1d"=>'\x1d',"\x1e"=>'\x1e',"\x1f"=>'\x1f',"\x7f"=>'\x7f',"\x80"=>'\x80',"\x81"=>'\x81',"\x82"=>'\x82',"\x83"=>'\x83',"\x84"=>'\x84',"\x86"=>'\x86',"\x87"=>'\x87',"\x88"=>'\x88',"\x89"=>'\x89',"\x8a"=>'\x8a',"\x8b"=>'\x8b',"\x8c"=>'\x8c',"\x8d"=>'\x8d',"\x8e"=>'\x8e',"\x8f"=>'\x8f',"\x90"=>'\x90',"\x91"=>'\x91',"\x92"=>'\x92',"\x93"=>'\x93',"\x94"=>'\x94',"\x95"=>'\x95',"\x96"=>'\x96',"\x97"=>'\x97',"\x98"=>'\x98',"\x99"=>'\x99',"\x9a"=>'\x9a',"\x9b"=>'\x9b',"\x9c"=>'\x9c',"\x9d"=>'\x9d',"\x9e"=>'\x9e',"\x9f"=>'\x9f',"\x{2029}"=>'\P',"\x{2028}"=>'\L',"\x85"=>'\N',"\xa0"=>'\_',);my$control_re='\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x84\x86-\x9f\x{d800}-\x{dfff}\x{fffe}\x{ffff}\x{2028}\x{2029}\x85\xa0';my%to_escape=("\n"=>'\n',"\t"=>'\t',"\r"=>'\r','\\'=>'\\\\','"'=>'\\"',%control,);my$escape_re=$control_re .'\n\t\r';my$escape_re_without_lb=$control_re .'\t\r';sub scalar_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ scalar_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$value=$info->{value};my$flow=$last->{flow};my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->_emit_tag('scalar',$tag)}$props=join ' ',grep defined,($anchor,$tag);DEBUG and local$Data::Dumper::Useqq=1;$value='' unless defined$value;my$style=$self->_find_best_scalar_style(info=>$info,value=>$value,);my$open_ended=0;if ($style==YAML_PLAIN_SCALAR_STYLE){$value =~ s/\n/\n\n/g}elsif ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){my$new_indent=$last->{indent}.(' ' x $self->indent);$value =~ s/(\n+)/"\n" x (1 + (length $1))/eg;my@lines=split m/\n/,$value,-1;if (@lines > 1){for my$line (@lines[1 .. $#lines]){$line=$new_indent .$line if length$line}}$value=join "\n",@lines;$value =~ s/'/''/g;$value="'" .$value ."'"}elsif ($style==YAML_LITERAL_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($value !~ m/\n\z/){$indicators .= '-';$value .= "\n"}elsif ($value =~ m/(\n|\A)\n\z/){$indicators .= '+';$open_ended=1}$value =~ s/^(?=.)/$indent/gm;$value="|$indicators\n$value"}elsif ($style==YAML_FOLDED_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my@lines=split /\n/,$value,-1;DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\@lines],['lines']);my$trailing=-1;while (@lines){last if$lines[-1]ne '';pop@lines;$trailing++}my%start_with_space;for my$i (0 .. $#lines){if ($lines[$i ]=~ m/^[ \t]+/){$start_with_space{$i }=1}}my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($trailing > 0){$indicators .= '+';$open_ended=1}elsif ($trailing < 0){$indicators .= '-'}$value=">$indicators\n";my$got_content=0;for my$i (0 .. $#lines){my$line=$lines[$i ];my$sp=$start_with_space{$i }|| 0;my$spnext=$i==$#lines ? 1 : $start_with_space{$i+1 }|| 0;my$spprev=$i==0 ? 1 : $start_with_space{$i-1 }|| 0;my$empty=length$line ? 0 : 1;my$emptynext=$i==$#lines ? '' : length$lines[$i+1]? 0 : 1;my$nl=0;if ($empty){if ($spnext and $spprev){$nl=1}elsif (not $spnext){$nl=1}elsif (not $got_content){$nl=1}}else {$got_content=1;$value .= "$indent$line\n";if (not $sp and not $spnext){$nl=1}}if ($nl){$value .= "\n"}}$value .= "\n" x ($trailing)if$trailing > 0}else {$value =~ s/([$escape_re"\\])/$to_escape{ $1 } || sprintf '\\u%04x', ord($1)/eg;$value='"' .$value .'"'}DEBUG and warn __PACKAGE__.':'.__LINE__.": (@$stack)\n";my$yaml=$self->_emit_scalar(indent=>$indent,props=>$props,value=>$value,style=>$style,);$last->{index}++;$last->{newline}=0;$self->_write($yaml);$last->{column}=$self->column;$self->{open_ended}=$open_ended}sub _find_best_scalar_style {my ($self,%args)=@_;my$info=$args{info};my$style=$info->{style};my$value=$args{value};my$stack=$self->event_stack;my$last=$stack->[-1];my$flow=$last->{flow};my$first=substr($value,0,1);if ($value eq ''){if ($flow and $last->{type}ne 'MAPVALUE' and $last->{type}ne 'MAP'){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (not $style){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}elsif ($value =~ m/[$control_re]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}$style ||= YAML_PLAIN_SCALAR_STYLE;if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){if ($value =~ m/ \n/ or $value =~ m/\n / or $value =~ m/^\n/ or $value =~ m/\n$/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}elsif ($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE){if ($value eq ''){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($flow){if ($value =~ tr/\n//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}else {$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}elsif ($style==YAML_PLAIN_SCALAR_STYLE){if (not length$value){}elsif ($value =~ m/[$escape_re_without_lb]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ //c){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ \n//c){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value =~ tr/\n//){$style=$flow ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_LITERAL_SCALAR_STYLE}elsif ($forbidden_first{$first }){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($flow and $value =~ tr/,[]{}//){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (substr($value,0,3)=~ m/^(?:---|\.\.\.)/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/: /){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/ #/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[: \t]\z/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[^\x20-\x3A\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($forbidden_first_plus_space{$first }){if (length ($value)==1 or substr($value,1,1)=~ m/^\s/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE and not $info->{style}){if ($value =~ tr/'// and $value !~ tr/"//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}return$style}sub _emit_scalar {my ($self,%args)=@_;my$props=$args{props};my$value=$args{value};my$style=$args{style};my$stack=$self->event_stack;my$last=$stack->[-1];my$flow=$last->{flow};my$yaml='';my$pvalue=$props;if ($props and length$value){$pvalue .= " $value"}elsif (length$value){$pvalue .= $value}if ($flow){if ($props and not length$value){$pvalue .= ' '}$yaml=$self->_emit_flow_scalar(value=>$value,pvalue=>$pvalue,style=>$args{style},)}else {$yaml=$self->_emit_block_scalar(props=>$props,value=>$value,pvalue=>$pvalue,indent=>$args{indent},style=>$args{style},)}return$yaml}sub _emit_block_scalar {my ($self,%args)=@_;my$props=$args{props};my$value=$args{value};my$pvalue=$args{pvalue};my$indent=$args{indent};my$style=$args{style};my$stack=$self->event_stack;my$last=$stack->[-1];my$yaml;if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}my$space=' ';my$multiline=($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE);if ($last->{type}eq 'MAP'){if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($props and not length$value){$pvalue .= ' '}$last->{type}='MAPVALUE';if ($multiline){$yaml .= "? ";$last->{type}='COMPLEXVALUE'}if (not $multiline){$pvalue .= ":"}}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ":"}elsif ($last->{type}eq 'SEQ'){$yaml .= "-"}else {die "Should not happen ($last->{type} in scalar_event)"}$last->{column}=1}if (length$pvalue){if ($last->{column}){$pvalue="$space$pvalue"}}if (not $multiline){$pvalue .= "\n"}}$yaml .= $pvalue;return$yaml}sub _emit_flow_scalar {my ($self,%args)=@_;my$value=$args{value};my$pvalue=$args{pvalue};my$stack=$self->event_stack;my$last=$stack->[-1];my$yaml;if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": ";$last->{type}='MAP'}if ($self->column + length$pvalue > $self->width){$yaml .= "\n";$yaml .= $last->{indent};$yaml .= ' ' x $self->indent}$yaml .= $pvalue;return$yaml}sub alias_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ alias_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$flow=$last->{flow};my$alias='*' .$info->{value};my$yaml='';if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}$yaml .= $last->{column}? ' ' : $indent;if ($flow){my$space='';if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE';$space=' '}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die 23;if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ": "}$last->{type}='MAP'}$yaml .= "$alias$space"}else {if ($last->{type}eq 'MAP'){$yaml .= "$alias :";$last->{type}='MAPVALUE'}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ": "}elsif ($last->{type}eq 'COMPLEX'){$yaml .= ": "}elsif ($last->{type}eq 'SEQ'){$yaml .= "- "}else {die "Unexpected"}}$yaml .= "$alias\n"}}$self->_write("$yaml");$last->{index}++;$last->{column}=$self->column;$self->{open_ended}=0}sub document_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_start_event\n";my ($self,$info)=@_;my$newline=0;my$implicit=$info->{implicit};if ($info->{version_directive}){if ($self->{open_ended}){$self->_write("...\n")}$self->_write("%YAML $info->{version_directive}->{major}.$info->{version_directive}->{minor}\n");$self->{open_ended}=0;$implicit=0}unless ($implicit){$newline=1;$self->_write("---")}$self->set_event_stack([{type=>'DOC',index=>0,indent=>'',info=>$info,newline=>$newline,column=>$self->column,}])}sub document_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_end_event\n";my ($self,$info)=@_;$self->set_event_stack([]);if ($self->{open_ended}or not $info->{implicit}){$self->_write("...\n");$self->{open_ended}=0}else {$self->{open_ended}=1}}sub stream_start_event {}sub stream_end_event {}sub _emit_tag {my ($self,$type,$tag)=@_;my$map=$self->tagmap;for my$key (sort keys %$map){if ($tag =~ m/^\Q$key\E(.*)/){$tag=$map->{$key }.$1;return$tag}}if ($tag =~ m/^(!.*)/){$tag="$1"}else {$tag="!<$tag>"}return$tag}sub finish {my ($self)=@_;$self->writer->finish}sub _write {my ($self,$yaml)=@_;return unless length$yaml;my@lines=split m/\n/,$yaml,-1;my$newlines=@lines - 1;$self->{line}+= $newlines;if (length$lines[-1]){if ($newlines){$self->{column}=length$lines[-1]}else {$self->{column}+= length$lines[-1]}}else {$self->{column}=0}$self->writer->write($yaml)}1;
YAML_PP_EMITTER

$fatpacked{"YAML/PP/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EXCEPTION';
  use strict;use warnings;package YAML::PP::Exception;our$VERSION='0.036';use overload '""'=>\&to_string;sub new {my ($class,%args)=@_;my$self=bless {line=>$args{line},msg=>$args{msg},next=>$args{next},where=>$args{where},yaml=>$args{yaml},got=>$args{got},expected=>$args{expected},column=>$args{column},},$class;return$self}sub to_string {my ($self)=@_;my$next=$self->{next};my$line=$self->{line};my$column=$self->{column};my$yaml='';for my$token (@$next){last if$token->{name}eq 'EOL';$yaml .= $token->{value}}$column='???' unless defined$column;my$remaining_yaml=$self->{yaml};$remaining_yaml='' unless defined$remaining_yaml;$yaml .= $remaining_yaml;{local $@;require Data::Dumper;local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;$yaml=Data::Dumper->Dump([$yaml],['yaml']);chomp$yaml}my$lines=5;my@fields;if ($self->{got}and $self->{expected}){$lines=6;$line=$self->{got}->{line};$column=$self->{got}->{column}+ 1;@fields=("Line"=>$line,"Column"=>$column,"Expected",join(" ",@{$self->{expected}}),"Got",$self->{got}->{name},"Where",$self->{where},"YAML",$yaml,)}else {@fields=("Line"=>$line,"Column"=>$column,"Message",$self->{msg},"Where",$self->{where},"YAML",$yaml,)}my$fmt=join "\n",("%-10s: %s")x $lines;my$string=sprintf$fmt,@fields;return$string}1;
YAML_PP_EXCEPTION

$fatpacked{"YAML/PP/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_GRAMMAR';
  use strict;use warnings;package YAML::PP::Grammar;our$VERSION='0.036';use base 'Exporter';our@EXPORT_OK=qw/$GRAMMAR/;our$GRAMMAR={};$GRAMMAR={'DIRECTIVE'=>{'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'DIRECTIVE' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }},'DOCUMENT_END'=>{'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'DOCUMENT_END' }},'END_FLOW'=>{'EOL'=>{'match'=>'cb_end_outer_flow','return'=>1 }},'FLOWMAP'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP_ANCHOR' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'match'=>'cb_anchor' },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWMAP_CONTENT' },'EOL'=>{'new'=>'FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'TAG'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP_TAG' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'match'=>'cb_tag' },'WS'=>{'new'=>'FLOWMAP' }},'FLOWMAP_CONTENT'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWMAP_EMPTYKEY'=>{'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 }},'FLOWMAP_EXPLICIT_KEY'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'FLOWMAP_EXPLICIT_KEY' },'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 },'WS'=>{'new'=>'FLOWMAP_EXPLICIT_KEY' }},'FLOWMAP_PROPS'=>{'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWSEQ'=>{'ALIAS'=>{'match'=>'cb_send_flow_alias','new'=>'FLOWSEQ_NEXT' },'COLON'=>{'EOL'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_EMPTY'=>{'FLOWSEQ_END'=>{'match'=>'cb_empty_flowseq_end','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowseq_comma','return'=>1 }},'FLOWSEQ_MAYBE_KEY'=>{'COLON'=>{'DEFAULT'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWSEQ_NEXT' },'WS'=>{'new'=>'FLOWSEQ_MAYBE_KEY' }},'FLOWSEQ_NEXT'=>{'EOL'=>{'new'=>'FLOWSEQ_NEXT' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','return'=>1 },'WS'=>{'new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_PROPS'=>{'COLON'=>{'EOL'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_END'=>{'match'=>'cb_empty_flowseq_end','return'=>1 },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flowseq_comma','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FULLMAPVALUE_INLINE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' }},'match'=>'cb_tag' }},'FULLNODE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_ANCHOR' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG_ANCHOR' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'NEWFLOWMAP'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'NEWFLOWMAP' },'QUESTION'=>{'match'=>'cb_flow_question','new'=>'FLOWMAP_EXPLICIT_KEY' },'WS'=>{'new'=>'NEWFLOWMAP' }},'NEWFLOWMAP_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' }},'NEWFLOWMAP_ANCHOR_SPC'=>{'DEFAULT'=>{'new'=>'FLOWMAP_PROPS' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'TAG'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' },'EOL'=>{'new'=>'FLOWMAP_PROPS' },'WS'=>{'new'=>'FLOWMAP_PROPS' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' }},'NEWFLOWMAP_TAG'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' }},'NEWFLOWMAP_TAG_SPC'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' },'EOL'=>{'new'=>'FLOWMAP_PROPS' },'WS'=>{'new'=>'FLOWMAP_PROPS' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWMAP_PROPS' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_TAG_SPC' }},'NEWFLOWSEQ'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ_ANCHOR' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ' },'EOL'=>{'new'=>'NEWFLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'TAG'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ_TAG' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ' }},'NEWFLOWSEQ_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' }},'NEWFLOWSEQ_ANCHOR_SPC'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_PROPS' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'TAG'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' },'EOL'=>{'new'=>'FLOWSEQ_PROPS' },'WS'=>{'new'=>'FLOWSEQ_PROPS' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' }},'NEWFLOWSEQ_TAG'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' }},'NEWFLOWSEQ_TAG_SPC'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' },'EOL'=>{'new'=>'FLOWSEQ_PROPS' },'WS'=>{'new'=>'FLOWSEQ_PROPS' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ_PROPS' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' }},'NODETYPE_COMPLEX'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_complexcolon' },'DEFAULT'=>{'match'=>'cb_empty_complexvalue','new'=>'NODETYPE_MAP' },'EOL'=>{'new'=>'NODETYPE_COMPLEX' }},'NODETYPE_FLOWMAP'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP' },'EOL'=>{'new'=>'NODETYPE_FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','new'=>'NEWFLOWMAP' },'WS'=>{'new'=>'NODETYPE_FLOWMAP' }},'NODETYPE_FLOWMAPVALUE'=>{'COLON'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR' },'match'=>'cb_flow_colon' },'EOL'=>{'new'=>'NODETYPE_FLOWMAPVALUE' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_value','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWMAPVALUE' }},'NODETYPE_FLOWSEQ'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ' },'EOL'=>{'new'=>'NODETYPE_FLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWSEQ' }},'NODETYPE_MAP'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' }},'match'=>'cb_tag' }},'NODETYPE_MAPVALUE_INLINE'=>{'ALIAS'=>{'EOL'=>{},'match'=>'cb_send_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUOTED'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' }},'NODETYPE_NODE'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqstart' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'NODETYPE_SCALAR_OR_MAP'=>{'ALIAS'=>{'EOL'=>{'match'=>'cb_send_alias_from_stack' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map_alias' }},'match'=>'cb_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_empty_map' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_questionstart' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'NODETYPE_SEQ'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqitem' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SEQ' }},'RULE_FLOWSCALAR'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flow_mapkey','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'match'=>'cb_send_scalar','return'=>1 },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'RULE_FULLFLOWSCALAR'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'match'=>'cb_tag' }},'RULE_FULLFLOWSCALAR_ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_tag' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' }},'RULE_FULLFLOWSCALAR_TAG'=>{'ANCHOR'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' }},'RULE_MAPKEY'=>{'ALIAS'=>{'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_send_alias_key' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_empty_mapkey' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'RULE_MAPKEY' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' }},'match'=>'cb_mapkey' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_question' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_take_quoted_key' }},'STREAM'=>{'DEFAULT'=>{'match'=>'cb_doc_start_implicit','new'=>'FULLNODE' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document_empty' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'STREAM' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }}};1;
YAML_PP_GRAMMAR

$fatpacked{"YAML/PP/Highlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_HIGHLIGHT';
  use strict;use warnings;package YAML::PP::Highlight;our$VERSION='0.036';our@EXPORT_OK=qw/Dump/;use base 'Exporter';use YAML::PP;use YAML::PP::Parser;use Encode;sub Dump {my (@docs)=@_;require YAML::PP::Schema::Perl;my$yp=YAML::PP->new(schema=>[qw/+ Perl/]);my$yaml=$yp->dump_string(@docs);my ($error,$tokens)=YAML::PP::Parser->yaml_to_tokens(string=>$yaml);my$highlighted=YAML::PP::Highlight->ansicolored($tokens);encode_utf8$highlighted}my%ansicolors=(ANCHOR=>[qw/green/],ALIAS=>[qw/bold green/],TAG=>[qw/bold blue/],INDENT=>[qw/white on_grey3/],COMMENT=>[qw/grey12/],COLON=>[qw/bold magenta/],DASH=>[qw/bold magenta/],QUESTION=>[qw/bold magenta/],YAML_DIRECTIVE=>[qw/cyan/],TAG_DIRECTIVE=>[qw/bold cyan/],SINGLEQUOTE=>[qw/bold green/],SINGLEQUOTED=>[qw/green/],SINGLEQUOTED_LINE=>[qw/green/],DOUBLEQUOTE=>[qw/bold green/],DOUBLEQUOTED=>[qw/green/],DOUBLEQUOTED_LINE=>[qw/green/],LITERAL=>[qw/bold yellow/],FOLDED=>[qw/bold yellow/],DOC_START=>[qw/bold/],DOC_END=>[qw/bold/],BLOCK_SCALAR_CONTENT=>[qw/yellow/],TAB=>[qw/on_blue/],ERROR=>[qw/bold red/],EOL=>[qw/grey12/],TRAILING_SPACE=>[qw/on_grey6/],FLOWSEQ_START=>[qw/bold magenta/],FLOWSEQ_END=>[qw/bold magenta/],FLOWMAP_START=>[qw/bold magenta/],FLOWMAP_END=>[qw/bold magenta/],FLOW_COMMA=>[qw/bold magenta/],PLAINKEY=>[qw/bright_blue/],);sub ansicolored {my ($class,$tokens,%args)=@_;my$expand_tabs=$args{expand_tabs};$expand_tabs=1 unless defined$expand_tabs;require Term::ANSIColor;local$Term::ANSIColor::EACHLINE="\n";my$ansi='';my$highlighted='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$color=$ansicolors{$name };if ($color){$str=Term::ANSIColor::colored($color,$str)}$highlighted .= $str}if ($expand_tabs){$highlighted =~ s/\t/' ' x 8/eg}$ansi .= $highlighted;return$ansi}my%htmlcolors=(ANCHOR=>'anchor',ALIAS=>'alias',SINGLEQUOTE=>'singlequote',DOUBLEQUOTE=>'doublequote',SINGLEQUOTED=>'singlequoted',DOUBLEQUOTED=>'doublequoted',SINGLEQUOTED_LINE=>'singlequoted',DOUBLEQUOTED_LINE=>'doublequoted',INDENT=>'indent',DASH=>'dash',COLON=>'colon',QUESTION=>'question',YAML_DIRECTIVE=>'yaml_directive',TAG_DIRECTIVE=>'tag_directive',TAG=>'tag',COMMENT=>'comment',LITERAL=>'literal',FOLDED=>'folded',DOC_START=>'doc_start',DOC_END=>'doc_end',BLOCK_SCALAR_CONTENT=>'block_scalar_content',TAB=>'tab',ERROR=>'error',EOL=>'eol',TRAILING_SPACE=>'trailing_space',FLOWSEQ_START=>'flowseq_start',FLOWSEQ_END=>'flowseq_end',FLOWMAP_START=>'flowmap_start',FLOWMAP_END=>'flowmap_end',FLOW_COMMA=>'flow_comma',PLAINKEY=>'plainkey',NOEOL=>'noeol',);sub htmlcolored {require HTML::Entities;my ($class,$tokens)=@_;my$html='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$colorclass=$htmlcolors{$name }|| 'default';$str=HTML::Entities::encode_entities($str);$html .= qq{<span class="$colorclass">$str</span>}}return$html}sub transform {my ($class,$tokens)=@_;my@list;for my$token (@$tokens){my@values;my$value=$token->{value};my$subtokens=$token->{subtokens};if ($subtokens){@values=@$subtokens}else {@values=$token}for my$token (@values){my$value=defined$token->{orig}? $token->{orig}: $token->{value};if ($token->{name}eq 'EOL' and not length$value){push@list,{name=>'NOEOL',value=>'' };next}push@list,map {$_ =~ tr/\t/\t/ ? {name=>'TAB',value=>$_ }: {name=>$token->{name},value=>$_ }}split m/(\t+)/,$value}}for my$i (0 .. $#list){my$token=$list[$i ];my$name=$token->{name};my$str=$token->{value};my$trailing_space=0;if ($token->{name}eq 'EOL'){if ($str =~ m/ +([\r\n]|\z)/){$token->{name}="TRAILING_SPACE"}}elsif ($i < $#list){if ($name eq 'PLAIN'){for my$n ($i+1 .. $#list){my$next=$list[$n ];last if$next->{name}eq 'EOL';next if$next->{name}=~ m/^(WS|SPACE)$/;if ($next->{name}eq 'COLON'){$token->{name}='PLAINKEY'}}}my$next=$list[$i + 1];if ($next->{name}eq 'EOL'){if ($str =~ m/ \z/ and $name =~ m/^(BLOCK_SCALAR_CONTENT|WS|INDENT)$/){$token->{name}="TRAILING_SPACE"}}}}return@list}1;
YAML_PP_HIGHLIGHT

$fatpacked{"YAML/PP/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LEXER';
  use strict;use warnings;package YAML::PP::Lexer;our$VERSION='0.036';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Grammar qw/$GRAMMAR/;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$self=bless {reader=>$args{reader},},$class;$self->init;return$self}sub init {my ($self)=@_;$self->{next_tokens}=[];$self->{next_line}=undef;$self->{line}=0;$self->{offset}=0;$self->{flowcontext}=0}sub next_line {return $_[0]->{next_line}}sub set_next_line {$_[0]->{next_line}=$_[1]}sub reader {return $_[0]->{reader}}sub set_reader {$_[0]->{reader}=$_[1]}sub next_tokens {return $_[0]->{next_tokens}}sub line {return $_[0]->{line}}sub set_line {$_[0]->{line}=$_[1]}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub inc_line {return $_[0]->{line}++}sub context {return $_[0]->{context}}sub set_context {$_[0]->{context}=$_[1]}sub flowcontext {return $_[0]->{flowcontext}}sub set_flowcontext {$_[0]->{flowcontext}=$_[1]}sub block {return $_[0]->{block}}sub set_block {$_[0]->{block}=$_[1]}my$RE_WS='[\t ]';my$RE_LB='[\r\n]';my$RE_DOC_END=qr/\A(\.\.\.)(?=$RE_WS|$)/m;my$RE_DOC_START=qr/\A(---)(?=$RE_WS|$)/m;my$RE_EOL=qr/\A($RE_WS+#.*|$RE_WS+)\z/;my$RE_NS_WORD_CHAR='[0-9A-Za-z-]';my$RE_URI_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} .')';my$RE_NS_TAG_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$_.~*'\(\)-]} .')';my$RE_ANCHOR_CAR='[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START='[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END='[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START_FLOW='[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END_FLOW='[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST_FLOW='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_WORD="(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_FIRST_WORD="(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_WORDS="(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORDS2="(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORD_FLOW="(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_FIRST_WORD_FLOW="(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_WORDS_FLOW="(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_PLAIN_WORDS_FLOW2="(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_TAG="!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";my$RE_SEQSTART=qr/\A(-)(?=$RE_WS|$)/m;my$RE_COMPLEX=qr/(\?)(?=$RE_WS|$)/m;my$RE_COMPLEXCOLON=qr/\A(:)(?=$RE_WS|$)/m;my$RE_ANCHOR="&$RE_ANCHOR_CAR+";my$RE_ALIAS="\\*$RE_ANCHOR_CAR+";my%REGEXES=(ANCHOR=>qr{($RE_ANCHOR)},TAG=>qr{($RE_TAG)},ALIAS=>qr{($RE_ALIAS)},SINGLEQUOTED=>qr{(?:''|[^'\r\n]+)*},);sub _fetch_next_line {my ($self)=@_;my$next_line=$self->next_line;if (defined$next_line){return$next_line}my$line=$self->reader->readline;unless (defined$line){$self->set_next_line(undef);return}$self->set_block(1);$self->inc_line;$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";$next_line=[$1,$2,$3 ];$self->set_next_line($next_line);if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//){$self->exception("Control characters are not allowed")}return$next_line}my%TOKEN_NAMES=('"'=>'DOUBLEQUOTE',"'"=>'SINGLEQUOTE','|'=>'LITERAL','>'=>'FOLDED','!'=>'TAG','*'=>'ALIAS','&'=>'ANCHOR',':'=>'COLON','-'=>'DASH','?'=>'QUESTION','['=>'FLOWSEQ_START',']'=>'FLOWSEQ_END','{'=>'FLOWMAP_START','}'=>'FLOWMAP_END',','=>'FLOW_COMMA','---'=>'DOC_START','...'=>'DOC_END',);sub fetch_next_tokens {my ($self)=@_;my$next=$self->next_tokens;return$next if @$next;my$next_line=$self->_fetch_next_line;if (not $next_line){return []}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];if (not length $$yaml){$self->_push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (substr($$yaml,0,1)eq '#'){$self->_push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (not $spaces and substr($$yaml,0,1)eq "%"){$self->_fetch_next_tokens_directive($yaml,$next_line->[2]);$self->set_context(0);$self->set_next_line(undef);return$next}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){$self->_push_tokens([$TOKEN_NAMES{$1 }=>$1,$self->line ])}elsif ($self->flowcontext and $$yaml =~ m/\A[ \t]+(#.*)?\z/){$self->_push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}else {$self->_push_tokens([SPACE=>$spaces,$self->line ])}my$partial=$self->_fetch_next_tokens($next_line);unless ($partial){$self->set_next_line(undef)}return$next}my%ANCHOR_ALIAS_TAG=('&'=>1,'*'=>1,'!'=>1);my%BLOCK_SCALAR=('|'=>1,'>'=>1);my%COLON_DASH_QUESTION=(':'=>1,'-'=>1,'?'=>1);my%QUOTED=('"'=>1,"'"=>1);my%FLOW=('{'=>1,'['=>1,'}'=>1,']'=>1,','=>1);my%CONTEXT=('"'=>1,"'"=>1,'>'=>1,'|'=>1);my$RE_ESCAPES=qr{(?:
      \\([ \\\/_0abefnrtvLNP\t"]) | \\x([0-9a-fA-F]{2})
      | \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
  )}x;my%CONTROL=('\\'=>'\\','/'=>'/',n=>"\n",t=>"\t",r=>"\r",b=>"\b",'a'=>"\a",'b'=>"\b",'e'=>"\e",'f'=>"\f",'v'=>"\x0b","\t"=>"\t",'P'=>"\x{2029}",L=>"\x{2028}",'N'=>"\x85",'0'=>"\0",'_'=>"\xa0",' '=>' ',q/"/=>q/"/,);sub _fetch_next_tokens {TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";my ($self,$next_line)=@_;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;while (1){unless (length $$yaml){push@tokens,(EOL=>$eol,$self->line);$self->_push_tokens(\@tokens);return}my$first=substr($$yaml,0,1);my$plain=0;if ($self->context){if ($$yaml =~ s/\A($RE_WS*)://){push@tokens,(WS=>$1,$self->line)if $1;push@tokens,(COLON=>':',$self->line);$self->set_context(0);next}if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//){push@tokens,(EOL=>$1 .$eol,$self->line);$self->_push_tokens(\@tokens);return}$self->set_context(0)}if ($CONTEXT{$first }){push@tokens,(CONTEXT=>$first,$self->line);$self->_push_tokens(\@tokens);return 1}elsif ($COLON_DASH_QUESTION{$first }){my$token_name=$TOKEN_NAMES{$first };if ($$yaml =~ s/\A\Q$first\E($RE_WS+|\z)//){my$after=$1;if (not $self->flowcontext and not $self->block){push@tokens,ERROR=>$first .$after,$self->line;$self->_push_tokens(\@tokens);$self->exception("Tabs can not be used for indentation")}if ($after =~ tr/\t//){$self->set_block(0)}my$token_name=$TOKEN_NAMES{$first };push@tokens,($token_name=>$first,$self->line);if (not defined $1){push@tokens,(EOL=>$eol,$self->line);$self->_push_tokens(\@tokens);return}my$ws=$1;if ($$yaml =~ s/\A(#.*|)\z//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->_push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line);next}elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//){push@tokens,($token_name=>$first,$self->line);next}$plain=1}elsif ($ANCHOR_ALIAS_TAG{$first }){my$token_name=$TOKEN_NAMES{$first };my$REGEX=$REGEXES{$token_name };if ($$yaml =~ s/\A$REGEX//){push@tokens,($token_name=>$1,$self->line)}else {push@tokens,("Invalid $token_name"=>$$yaml,$self->line);$self->_push_tokens(\@tokens);return}}elsif ($first eq ' ' or $first eq "\t"){if ($$yaml =~ s/\A($RE_WS+)//){my$ws=$1;if ($$yaml =~ s/\A((?:#.*)?\z)//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->_push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line)}}elsif ($FLOW{$first }){push@tokens,($TOKEN_NAMES{$first }=>$first,$self->line);substr($$yaml,0,1,'');my$flowcontext=$self->flowcontext;if ($first eq '{' or $first eq '['){$self->set_flowcontext(++$flowcontext)}elsif ($first eq '}' or $first eq ']'){$self->set_flowcontext(--$flowcontext)}}else {$plain=1}if ($plain){push@tokens,(CONTEXT=>'',$self->line);$self->_push_tokens(\@tokens);return 1}}return}sub fetch_plain {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my$REGEX=$RE_PLAIN_WORDS;if ($self->flowcontext){$REGEX=$RE_PLAIN_WORDS_FLOW}my@tokens;unless ($$yaml =~ s/\A($REGEX)//){$self->_push_tokens(\@tokens);$self->exception("Invalid plain scalar")}my$plain=$1;push@tokens,(PLAIN=>$plain,$self->line);if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//){if (defined $1){push@tokens,(EOL=>$1 .$eol,$self->line);$self->_push_tokens(\@tokens);$self->set_next_line(undef);return}else {push@tokens,(EOL=>$2.$eol,$self->line);$self->set_next_line(undef)}}else {$self->_push_tokens(\@tokens);my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return}my$RE2=$RE_PLAIN_WORDS2;if ($self->flowcontext){$RE2=$RE_PLAIN_WORDS_FLOW2}my$fetch_next=0;my@lines=($plain);my@next;LOOP: while (1){$next_line=$self->_fetch_next_line;if (not $next_line){last LOOP}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];my$eol=$next_line->[2];if (not length $$yaml){push@tokens,(EOL=>$spaces .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){push@next,$TOKEN_NAMES{$1 }=>$1,$self->line;$fetch_next=1;last LOOP}if ((length$spaces)< $indent){last LOOP}my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,(EOL=>$spaces .$ws .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,(EOL=>$spaces .$ws .$1 .$eol,$self->line);$self->set_next_line(undef);last LOOP}if ($$yaml =~ s/\A($RE2)//){push@tokens,INDENT=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;push@tokens,PLAIN=>$1,$self->line;push@lines,$1;my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,EOL=>$ws .$eol,$self->line;$self->set_next_line(undef);next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,EOL=>$ws .$1 .$eol,$self->line;$self->set_next_line(undef);last LOOP}else {push@tokens,WS=>$ws,$self->line if$ws;$fetch_next=1}}else {push@tokens,SPACE=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;if ($self->flowcontext){$fetch_next=1}else {push@tokens,ERROR=>$$yaml,$self->line}}last LOOP}while (@lines > 1 and $lines[-1]eq ''){pop@lines}if (@lines > 1){my$value=YAML::PP::Render->render_multi_val(\@lines);my@eol;if ($tokens[-3]eq 'EOL'){@eol=splice@tokens,-3}$self->push_subtokens({name=>'PLAIN_MULTI',value=>$value },\@tokens);$self->_push_tokens([@eol,@next ])}else {$self->_push_tokens([@tokens,@next ])}@tokens=();if ($fetch_next){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}}return}sub fetch_block {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context\E// or die "Unexpected";push@tokens,($token_name=>$context,$self->line);my$current_indent=$indent;my$started=0;my$set_indent=0;my$chomp='';if ($$yaml =~ s/\A([1-9])([+-]?)//){push@tokens,(BLOCK_SCALAR_INDENT=>$1,$self->line);$set_indent=$1;$chomp=$2 if $2;push@tokens,(BLOCK_SCALAR_CHOMP=>$2,$self->line)if $2}elsif ($$yaml =~ s/\A([+-])([1-9])?//){push@tokens,(BLOCK_SCALAR_CHOMP=>$1,$self->line);$chomp=$1;push@tokens,(BLOCK_SCALAR_INDENT=>$2,$self->line)if $2;$set_indent=$2 if $2}if ($set_indent){$started=1;$indent-- if$indent > 0;$current_indent=$indent + $set_indent}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//){push@tokens,(EOL=>$1 .$eol,$self->line)}else {$self->_push_tokens(\@tokens);$self->exception("Invalid block scalar")}my@lines;while (1){$self->set_next_line(undef);$next_line=$self->_fetch_next_line;if (not $next_line){last}my$spaces=$next_line->[0];my$content=$next_line->[1];my$eol=$next_line->[2];if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){last}if ((length$spaces)< $current_indent){if (length$content){if ($content =~ m/\A\t/){$self->_push_tokens(\@tokens);$self->exception("Invalid block scalar")}last}else {push@lines,'';push@tokens,(EOL=>$spaces .$eol,$self->line);next}}if ((length$spaces)> $current_indent){if ($started){($spaces,my$more_spaces)=unpack "a${current_indent}a*",$spaces;$content=$more_spaces .$content}}unless (length$content){push@lines,'';push@tokens,(INDENT=>$spaces,$self->line,EOL=>$eol,$self->line);unless ($started){$current_indent=length$spaces}next}unless ($started){$started=1;$current_indent=length$spaces}push@lines,$content;push@tokens,(INDENT=>$spaces,$self->line,BLOCK_SCALAR_CONTENT=>$content,$self->line,EOL=>$eol,$self->line,)}my$value=YAML::PP::Render->render_block_scalar($context,$chomp,\@lines);my@eol=splice@tokens,-3;$self->push_subtokens({name=>'BLOCK_SCALAR',value=>$value },\@tokens);$self->_push_tokens([@eol ]);return 0}sub fetch_quoted {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$spaces=$next_line->[0];my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context// or die "Unexpected";;my@tokens=($token_name=>$context,$self->line);my$start=1;my@values;while (1){unless ($start){$next_line=$self->_fetch_next_line or do {for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->_push_tokens(\@tokens);$self->exception("Missing closing quote <$context> at EOF")};$start=0;$spaces=$next_line->[0];$yaml=\$next_line->[1];if (not length $$yaml){push@tokens,(EOL=>$spaces .$next_line->[2],$self->line);$self->set_next_line(undef);push@values,{value=>'',orig=>'' };next}elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->_push_tokens(\@tokens);$self->exception("Missing closing quote <$context> or invalid document marker")}elsif ((length$spaces)< $indent){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->_push_tokens(\@tokens);$self->exception("Wrong indendation or missing closing quote <$context>")}if ($$yaml =~ s/\A($RE_WS+)//){$spaces .= $1}push@tokens,(WS=>$spaces,$self->line)}my$v=$self->_read_quoted_tokens($start,$context,$yaml,\@tokens);push@values,$v;if ($tokens[-3]eq $token_name){if ($start){$self->push_subtokens({name=>'QUOTED',value=>$v->{value}},\@tokens)}else {my$value=YAML::PP::Render->render_quoted($context,\@values);$self->push_subtokens({name=>'QUOTED_MULTILINE',value=>$value },\@tokens)}$self->set_context(1)if$self->flowcontext;if (length $$yaml){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return 0}else {@tokens=();push@tokens,(EOL=>$next_line->[2],$self->line);$self->_push_tokens(\@tokens);$self->set_next_line(undef);return}}$tokens[-2].= $next_line->[2];$self->set_next_line(undef);$start=0}}sub _read_quoted_tokens {my ($self,$start,$first,$yaml,$tokens)=@_;my$quoted='';my$decoded='';my$token_name=$TOKEN_NAMES{$first };my$eol='';if ($first eq "'"){my$regex=$REGEXES{SINGLEQUOTED};if ($$yaml =~ s/\A($regex)//){$quoted .= $1;$decoded .= $1;$decoded =~ s/''/'/g}unless (length $$yaml){if ($quoted =~ s/($RE_WS+)\z//){$eol=$1;$decoded =~ s/($eol)\z//}}}else {($quoted,$decoded,$eol)=$self->_read_doublequoted($yaml)}my$value={value=>$decoded,orig=>$quoted };if ($$yaml =~ s/\A$first//){if ($start){push @$tokens,($token_name .'D'=>$value,$self->line)}else {push @$tokens,($token_name .'D_LINE'=>$value,$self->line)}push @$tokens,($token_name=>$first,$self->line);return$value}if (length $$yaml){push @$tokens,($token_name .'D'=>$value->{orig},$self->line);$self->_push_tokens($tokens);$self->exception("Invalid quoted <$first> string")}push @$tokens,($token_name .'D_LINE'=>$value,$self->line);push @$tokens,(EOL=>$eol,$self->line);return$value}sub _read_doublequoted {my ($self,$yaml)=@_;my$quoted='';my$decoded='';my$eol='';while (1){my$last=1;if ($$yaml =~ s/\A([^"\\ \t]+)//){$quoted .= $1;$decoded .= $1;$last=0}if ($$yaml =~ s/\A($RE_ESCAPES)//){$quoted .= $1;my$dec=defined $2 ? $CONTROL{$2 }: defined $3 ? chr hex $3 : defined $4 ? chr hex $4 : chr hex $5;$decoded .= $dec;$last=0}if ($$yaml =~ s/\A([ \t]+)//){my$spaces=$1;if (length $$yaml){$quoted .= $spaces;$decoded .= $spaces;$last=0}else {$eol=$spaces;last}}if ($$yaml =~ s/\A(\\)\z//){$quoted .= $1;$decoded .= $1;last}last if$last}return ($quoted,$decoded,$eol)}sub _fetch_next_tokens_directive {my ($self,$yaml,$eol)=@_;my@tokens;my$trailing_ws='';my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($$yaml =~ s/\A(\s*%YAML[ \t]+([0-9]+\.[0-9]+))//){my$dir=$1;my$version=$2;if ($$yaml =~ s/\A($RE_WS+)//){$trailing_ws=$1}elsif (length $$yaml){push@tokens,('Invalid directive'=>$dir.$$yaml.$eol,$self->line);$self->_push_tokens(\@tokens);return}if ($version !~ m/^1\.[12]$/){if ($warn eq 'warn'){warn "Unsupported YAML version '$dir'"}elsif ($warn eq 'fatal'){push@tokens,('Unsupported YAML version'=>$dir,$self->line);$self->_push_tokens(\@tokens);return}}push@tokens,(YAML_DIRECTIVE=>$dir,$self->line)}elsif ($$yaml =~ s/\A(\s*%TAG[ \t]+(!$RE_NS_WORD_CHAR*!|!)[ \t]+(tag:\S+|!$RE_URI_CHAR+))($RE_WS*)//){push@tokens,(TAG_DIRECTIVE=>$1,$self->line);my$tag_alias=$2;my$tag_url=$3;$trailing_ws=$4}elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//){push@tokens,(RESERVED_DIRECTIVE=>$1,$self->line);if ($warn eq 'warn'){warn "Found reserved directive '$1'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$1'"}}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->_push_tokens(\@tokens);return}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}elsif ($trailing_ws and $$yaml =~ s/\A(#.*)?\z//){push@tokens,(EOL=>"$trailing_ws$1$eol",$self->line);$self->_push_tokens(\@tokens);return}elsif ($$yaml =~ s/\A([ \t]+#.*)?\z//){push@tokens,(EOL=>"$1$eol",$self->line);$self->_push_tokens(\@tokens);return}else {push@tokens,('Invalid directive'=>$trailing_ws.$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line)}$self->_push_tokens(\@tokens);return}sub _push_tokens {my ($self,$new_tokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;for (my$i=0;$i < @$new_tokens;$i += 3){my$value=$new_tokens->[$i + 1 ];my$name=$new_tokens->[$i ];my$line=$new_tokens->[$i + 2 ];my$push={name=>$name,line=>$line,column=>$column,value=>$value,};$column += length$value unless$name eq 'CONTEXT';push @$next,$push;if ($name eq 'EOL'){$column=0}}$self->set_offset($column);return$next}sub push_subtokens {my ($self,$token,$subtokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;$token->{column}=$column;$token->{subtokens}=\my@sub;for (my$i=0;$i < @$subtokens;$i+=3){my$name=$subtokens->[$i ];my$value=$subtokens->[$i + 1 ];my$line=$subtokens->[$i + 2 ];my$push={name=>$subtokens->[$i ],line=>$line,column=>$column,};if (ref$value eq 'HASH'){%$push=(%$push,%$value);$column += length$value->{orig}}else {$push->{value}=$value;$column += length$value}if ($push->{name}eq 'EOL'){$column=0}push@sub,$push}$token->{line}=$sub[0]->{line};push @$next,$token;$self->set_offset($column);return$next}sub exception {my ($self,$msg)=@_;my$next=$self->next_tokens;$next=[];my$line=@$next ? $next->[0]->{line}: $self->line;my@caller=caller(0);my$yaml='';if (my$nl=$self->next_line){$yaml=join '',@$nl;$yaml=$nl->[1]}my$e=YAML::PP::Exception->new(line=>$line,column=>$self->offset + 1,msg=>$msg,next=>$next,where=>$caller[1].' line ' .$caller[2],yaml=>$yaml,);croak$e}1;
YAML_PP_LEXER

$fatpacked{"YAML/PP/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LOADER';
  use strict;use warnings;package YAML::PP::Loader;our$VERSION='0.036';use YAML::PP::Parser;use YAML::PP::Constructor;use YAML::PP::Reader;sub new {my ($class,%args)=@_;my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$default_yaml_version=delete$args{default_yaml_version}|| '1.2';my$preserve=delete$args{preserve};my$duplicate_keys=delete$args{duplicate_keys};my$schemas=delete$args{schemas};$schemas ||= {'1.2'=>YAML::PP->default_schema(boolean=>'perl',)};my$constructor=delete$args{constructor}|| YAML::PP::Constructor->new(schemas=>$schemas,cyclic_refs=>$cyclic_refs,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$parser=delete$args{parser};unless ($parser){$parser=YAML::PP::Parser->new(default_yaml_version=>$default_yaml_version,)}unless ($parser->receiver){$parser->set_receiver($constructor)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {parser=>$parser,constructor=>$constructor,},$class;return$self}sub clone {my ($self)=@_;my$clone={parser=>$self->parser->clone,constructor=>$self->constructor->clone,};bless$clone,ref$self;$clone->parser->set_receiver($clone->constructor);return$clone}sub parser {return $_[0]->{parser}}sub constructor {return $_[0]->{constructor}}sub filename {my ($self)=@_;my$reader=$self->parser->reader;if ($reader->isa('YAML::PP::Reader::File')){return$reader->input}die "Reader is not a YAML::PP::Reader::File"}sub load_string {my ($self,$yaml)=@_;$self->parser->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->load()}sub load_file {my ($self,$file)=@_;$self->parser->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->load()}sub load {my ($self)=@_;my$parser=$self->parser;my$constructor=$self->constructor;$constructor->init;$parser->parse();my$docs=$constructor->docs;return wantarray ? @$docs : $docs->[0]}1;
YAML_PP_LOADER

$fatpacked{"YAML/PP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PARSER';
  use strict;use warnings;package YAML::PP::Parser;our$VERSION='0.036';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use YAML::PP::Render;use YAML::PP::Lexer;use YAML::PP::Grammar qw/$GRAMMAR/;use YAML::PP::Exception;use YAML::PP::Reader;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$reader=delete$args{reader}|| YAML::PP::Reader->new;my$default_yaml_version=delete$args{default_yaml_version};my$self=bless {default_yaml_version=>$default_yaml_version || '1.2',lexer=>YAML::PP::Lexer->new(reader=>$reader,),},$class;my$receiver=delete$args{receiver};if ($receiver){$self->set_receiver($receiver)}return$self}sub clone {my ($self)=@_;my$clone={default_yaml_version=>$self->default_yaml_version,lexer=>YAML::PP::Lexer->new(),};return bless$clone,ref$self}sub receiver {return $_[0]->{receiver}}sub set_receiver {my ($self,$receiver)=@_;my$callback;if (ref$receiver eq 'CODE'){$callback=$receiver}else {$callback=sub {my ($self,$event,$info)=@_;return$receiver->$event($info)}}$self->{callback}=$callback;$self->{receiver}=$receiver}sub reader {return $_[0]->lexer->{reader}}sub set_reader {my ($self,$reader)=@_;$self->lexer->set_reader($reader)}sub lexer {return $_[0]->{lexer}}sub callback {return $_[0]->{callback}}sub set_callback {$_[0]->{callback}=$_[1]}sub level {return $#{$_[0]->{offset}}}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub events {return $_[0]->{events}}sub set_events {$_[0]->{events}=$_[1]}sub new_node {return $_[0]->{new_node}}sub set_new_node {$_[0]->{new_node}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub tokens {return $_[0]->{tokens}}sub set_tokens {$_[0]->{tokens}=$_[1]}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub yaml_version_directive {return $_[0]->{yaml_version_directive}}sub set_yaml_version_directive {$_[0]->{yaml_version_directive}=$_[1]}sub rule {return $_[0]->{rule}}sub set_rule {my ($self,$name)=@_;no warnings 'uninitialized';DEBUG and $self->info("set_rule($name)");$self->{rule}=$name}sub init {my ($self)=@_;$self->set_offset([]);$self->set_events([]);$self->set_new_node(0);$self->set_tagmap({'!!'=>"tag:yaml.org,2002:",});$self->set_tokens([]);$self->set_rule(undef);$self->set_event_stack([]);$self->set_yaml_version($self->default_yaml_version);$self->set_yaml_version_directive(undef);$self->lexer->init}sub parse_string {my ($self,$yaml)=@_;$self->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->parse()}sub parse_file {my ($self,$file)=@_;$self->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->parse()}my%nodetypes=(MAPVALUE=>'NODETYPE_COMPLEX',MAP=>'NODETYPE_MAP',SEQ=>'NODETYPE_SEQ',SEQ0=>'NODETYPE_SEQ',FLOWMAP=>'NODETYPE_FLOWMAP',FLOWMAPVALUE=>'NODETYPE_FLOWMAPVALUE',FLOWSEQ=>'NODETYPE_FLOWSEQ',FLOWSEQ_NEXT=>'FLOWSEQ_NEXT',DOC=>'FULLNODE',DOC_END=>'DOCUMENT_END',STR=>'STREAM',END_FLOW=>'END_FLOW',);sub parse {my ($self)=@_;TRACE and warn "=== parse()\n";TRACE and $self->debug_yaml;$self->init;$self->lexer->init;eval {$self->start_stream;$self->set_rule('STREAM');$self->parse_tokens();$self->end_stream};if (my$error=$@){if (ref$error){croak "$error\n "}croak$error}DEBUG and $self->highlight_yaml;TRACE and $self->debug_tokens}sub lex_next_tokens {my ($self)=@_;DEBUG and $self->info("----------------> lex_next_tokens");TRACE and $self->debug_events;my$indent=$self->offset->[-1];my$event_types=$self->events;my$next_tokens=$self->lexer->fetch_next_tokens($indent);return unless @$next_tokens;my$next=$next_tokens->[0];return 1 if ($next->{name}ne 'SPACE');my$flow=$event_types->[-1]=~ m/^FLOW/;my$space=length$next->{value};my$tokens=$self->tokens;if (not $space){shift @$next_tokens}else {push @$tokens,shift @$next_tokens}if ($flow){if ($space >= $indent){return 1}$self->exception("Bad indendation in " .$self->events->[-1])}$next=$next_tokens->[0];if ($space > $indent){return 1 if$indent < 0;unless ($self->new_node){$self->exception("Bad indendation in " .$self->events->[-1])}return 1}if ($self->new_node){if ($space < $indent){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$self->remove_nodes($space)}else {my$exp=$self->events->[-1];my$seq_start=$next->{name}eq 'DASH';if ($seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')){}else {$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}}}else {if ($space < $indent){$self->remove_nodes($space)}}my$exp=$self->events->[-1];if ($exp eq 'SEQ0' and $next->{name}ne 'DASH'){TRACE and $self->info("In unindented sequence");$self->end_sequence;$exp=$self->events->[-1]}if ($self->offset->[-1]!=$space){$self->exception("Expected " .$self->events->[-1])}return 1}my%next_event=(MAP=>'MAPVALUE',IMAP=>'IMAPVALUE',MAPVALUE=>'MAP',IMAPVALUE=>'IMAP',SEQ=>'SEQ',SEQ0=>'SEQ0',DOC=>'DOC_END',STR=>'STR',FLOWSEQ=>'FLOWSEQ_NEXT',FLOWSEQ_NEXT=>'FLOWSEQ',FLOWMAP=>'FLOWMAPVALUE',FLOWMAPVALUE=>'FLOWMAP',);my%event_to_method=(MAP=>'mapping',IMAP=>'mapping',FLOWMAP=>'mapping',SEQ=>'sequence',SEQ0=>'sequence',FLOWSEQ=>'sequence',DOC=>'document',STR=>'stream',VAL=>'scalar',ALI=>'alias',MAPVALUE=>'mapping',IMAPVALUE=>'mapping',);my%fetch_method=('"'=>'fetch_quoted',"'"=>'fetch_quoted','|'=>'fetch_block','>'=>'fetch_block',''=>'fetch_plain',);sub parse_tokens {my ($self)=@_;my$event_types=$self->events;my$offsets=$self->offset;my$tokens=$self->tokens;my$next_tokens=$self->lexer->next_tokens;unless ($self->lex_next_tokens){$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){my$new_rule=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($new_rule)}}my$rule_name=$self->rule;DEBUG and $self->info("----------------> parse_tokens($rule_name)");my$rule=$GRAMMAR->{$rule_name }or die "Could not find rule $rule_name";TRACE and $self->debug_rules($rule);TRACE and $self->debug_yaml;DEBUG and $self->debug_next_line;RULE: while ($rule_name){DEBUG and $self->info("RULE: $rule_name");TRACE and $self->debug_tokens($next_tokens);unless (@$next_tokens){$self->exception("No more tokens")}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]],['next_token']);my$got=$next_tokens->[0]->{name};if ($got eq 'CONTEXT'){my$context=shift @$next_tokens;my$indent=$offsets->[-1];$indent++ unless$self->lexer->flowcontext;my$method=$fetch_method{$context->{value}};my$partial=$self->lexer->$method($indent,$context->{value});next RULE}my$def=$rule->{$got };if ($def){push @$tokens,shift @$next_tokens}elsif ($def=$rule->{DEFAULT}){$got='DEFAULT'}else {$self->expected(expected=>[keys %$rule],got=>$next_tokens->[0],)}DEBUG and $self->got("---got $got");if (my$sub=$def->{match}){DEBUG and $self->info("CALLBACK $sub");$self->$sub(@$tokens ? $tokens->[-1]: ())}my$eol=$got eq 'EOL';my$new=$def->{new};if ($new){DEBUG and $self->got("NEW: $new");$rule_name=$new;$self->set_rule($rule_name)}elsif ($eol){}elsif ($def->{return}){$rule_name=$nodetypes{$event_types->[-1]}or die "Unexpected event type $event_types->[-1]";$self->set_rule($rule_name)}else {$rule_name .= " - $got";$rule=$def;next RULE}if ($eol){unless ($self->lex_next_tokens){if ($rule_name eq 'DIRECTIVE'){$self->exception("Directive needs document start")}$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){$rule_name=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($rule_name)}}$rule_name=$self->rule}$rule=$GRAMMAR->{$rule_name }or die "Unexpected rule $rule_name"}die "Unexpected"}sub end_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]}}sub remove_nodes {my ($self,$space)=@_;my$offset=$self->offset;my$event_types=$self->events;my$exp=$event_types->[-1];while (@$offset){if ($offset->[-1 ]<= $space){last}if ($exp eq 'MAPVALUE'){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$exp='MAP'}my$info={name=>$exp };$info->{name}=$event_to_method{$exp }.'_end_event';pop @{$event_types};pop @{$offset};$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]};$exp=$event_types->[-1]}return$exp}sub start_stream {my ($self)=@_;push @{$self->events},'STR';push @{$self->offset},-1;$self->callback->($self,'stream_start_event',{name=>'stream_start_event',})}sub start_document {my ($self,$implicit)=@_;push @{$self->events},'DOC';push @{$self->offset},-1;my$directive=$self->yaml_version_directive;my%directive;if ($directive){my ($major,$minor)=split m/\./,$self->yaml_version;%directive=(version_directive=>{major=>$major,minor=>$minor })}$self->callback->($self,'document_start_event',{name=>'document_start_event',implicit=>$implicit,%directive,});$self->set_yaml_version_directive(undef);$self->set_rule('FULLNODE');$self->set_new_node(1)}sub start_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;if ($offsets->[-1]==$offset){push @{$self->events},'SEQ0'}else {push @{$self->events},'SEQ'}push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},'FLOWSEQ';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={style=>YAML_FLOW_SEQUENCE_STYLE,name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_mapping {my ($self,$offset,$implicit_flowseq_map)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},$implicit_flowseq_map ? 'IMAP' : 'FLOWMAP';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event',style=>YAML_FLOW_MAPPING_STYLE };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_flow_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name},$info);if ($event_types->[-1]=~ m/^FLOW|^IMAP/){$event_types->[-1]=$next_event{$event_types->[-1]}}else {push @$event_types,'END_FLOW'}}sub end_flow_mapping {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'mapping_end_event' };$self->callback->($self,$info->{name},$info);if ($event_types->[-1]=~ m/^FLOW|^IMAP/){$event_types->[-1]=$next_event{$event_types->[-1]}}else {push @$event_types,'END_FLOW'}}sub cb_end_outer_flow {my ($self)=@_;my$event_types=$self->events;pop @$event_types;$event_types->[-1]=$next_event{$event_types->[-1]}}sub start_mapping {my ($self,$offset)=@_;my$offsets=$self->offset;push @{$self->events},'MAP';push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_document {my ($self,$implicit)=@_;my$event_types=$self->events;if ($event_types->[-1]=~ m/FLOW/){die "Unexpected end of flow context"}if ($self->new_node){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}$self->remove_nodes(-1);if ($event_types->[-1]eq 'STR'){return}my$last=pop @{$event_types};if ($last ne 'DOC' and $last ne 'DOC_END'){$self->exception("Unexpected event type $last")}pop @{$self->offset};$self->callback->($self,'document_end_event',{name=>'document_end_event',implicit=>$implicit,});if ($self->yaml_version eq '1.2'){$self->set_tagmap({'!!'=>"tag:yaml.org,2002:" })}$event_types->[-1]=$next_event{$event_types->[-1]};$self->set_rule('STREAM')}sub end_stream {my ($self)=@_;my$last=pop @{$self->events};$self->exception("Unexpected event type $last")unless$last eq 'STR';pop @{$self->offset};$self->callback->($self,'stream_end_event',{name=>'stream_end_event',})}sub fetch_inline_properties {my ($self,$stack,$info)=@_;my$properties=$stack->[-1];$properties=$properties->[1];my$property_offset;if ($properties){for my$p (@{$properties->{inline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value};unless (defined$property_offset){$property_offset=$p->{offset};$info->{offset}=$p->{offset}}}delete$properties->{inline};undef$properties unless$properties->{newline}}unless ($properties){pop @$stack}}sub node_properties {my ($self,$properties,$info)=@_;if ($properties){for my$p (@{$properties->{newline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value}}undef$properties}}sub scalar_event {my ($self,$info)=@_;my$event_types=$self->events;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$properties=$self->node_properties($properties->[1],$info)}$info->{name}='scalar_event';$self->callback->($self,'scalar_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub alias_event {my ($self,$info)=@_;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->exception("Parse error: Alias not allowed in this context")}my$event_types=$self->events;$info->{name}='alias_event';$self->callback->($self,'alias_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub yaml_to_tokens {my ($class,$type,$input)=@_;my$yp=YAML::PP::Parser->new(receiver=>sub {});my@docs=eval {$type eq 'string' ? $yp->parse_string($input): $yp->parse_file($input)};my$error=$@;my$tokens=$yp->tokens;if ($error){my$remaining_tokens=$yp->_remaining_tokens;push @$tokens,map {+{%$_,name=>'ERROR' }}@$remaining_tokens}return$error,$tokens}sub _remaining_tokens {my ($self)=@_;my@tokens;my$next=$self->lexer->next_tokens;push@tokens,@$next;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}$remaining .= $self->reader->read;$remaining='' unless defined$remaining;push@tokens,{name=>"ERROR",value=>$remaining };return \@tokens}sub event_to_test_suite {my ($self,$event)=@_;if (ref$event eq 'ARRAY'){return YAML::PP::Common::event_to_test_suite($event->[1])}return YAML::PP::Common::event_to_test_suite($event)}sub debug_events {my ($self)=@_;$self->note("EVENTS: (" .join (' | ',@{$_[0]->events}).')');$self->debug_offset}sub debug_offset {my ($self)=@_;$self->note(qq{OFFSET: (} .join (' | ',map {defined $_ ? sprintf "%-3d",$_ : '?'}@{$_[0]->offset}).qq/) level=@{[ $_[0]->level ]}]}/)}sub debug_yaml {my ($self)=@_;my$line=$self->lexer->line;$self->note("LINE NUMBER: $line");my$next_tokens=$self->lexer->next_tokens;if (@$next_tokens){$self->debug_tokens($next_tokens)}}sub debug_next_line {my ($self)=@_;my$next_line=$self->lexer->next_line || [];my$line=$next_line->[0];$line='' unless defined$line;$line =~ s/( +)$/'·' x length $1/e;$line =~ s/\t/▸/g;$self->note("NEXT LINE: >>$line<<")}sub note {my ($self,$msg)=@_;$self->_colorize_warn(["yellow"],"============ $msg")}sub info {my ($self,$msg)=@_;$self->_colorize_warn(["cyan"],"============ $msg")}sub got {my ($self,$msg)=@_;$self->_colorize_warn(["green"],"============ $msg")}sub _colorize_warn {my ($self,$colors,$text)=@_;require Term::ANSIColor;warn Term::ANSIColor::colored($colors,$text),"\n"}sub debug_event {my ($self,$event)=@_;my$str=YAML::PP::Common::event_to_test_suite($event);require Term::ANSIColor;warn Term::ANSIColor::colored(["magenta"],"============ $str"),"\n"}sub debug_rules {my ($self,$rules)=@_;local$Data::Dumper::Maxdepth=2;$self->note("RULES:");for my$rule ($rules){if (ref$rule eq 'ARRAY'){my$first=$rule->[0];if (ref$first eq 'SCALAR'){$self->info("-> $$first")}else {if (ref$first eq 'ARRAY'){$first=$first->[0]}$self->info("TYPE $first")}}else {eval {my@keys=sort keys %$rule;$self->info("@keys")}}}}sub debug_tokens {my ($self,$tokens)=@_;$tokens ||= $self->tokens;require Term::ANSIColor;for my$token (@$tokens){my$type=Term::ANSIColor::colored(["green"],sprintf "%-22s L %2d C %2d ",$token->{name},$token->{line},$token->{column}+ 1);local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;require Data::Dumper;my$str=Data::Dumper->Dump([$token->{value}],['str']);chomp$str;$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge;warn "$type$str\n"}}sub highlight_yaml {my ($self)=@_;require YAML::PP::Highlight;my$tokens=$self->tokens;my$highlighted=YAML::PP::Highlight->ansicolored($tokens);warn$highlighted}sub exception {my ($self,$msg,%args)=@_;my$next=$self->lexer->next_tokens;my$line=@$next ? $next->[0]->{line}: $self->lexer->line;my$offset=@$next ? $next->[0]->{column}: $self->lexer->offset;$offset++;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}my$caller=$args{caller}|| [caller(0)];my$e=YAML::PP::Exception->new(got=>$args{got},expected=>$args{expected},line=>$line,column=>$offset,msg=>$msg,next=>$next,where=>$caller->[1].' line ' .$caller->[2],yaml=>$remaining,);croak$e}sub expected {my ($self,%args)=@_;my$expected=$args{expected};@$expected=sort grep {m/^[A-Z_]+$/}@$expected;my$got=$args{got}->{name};my@caller=caller(0);$self->exception("Expected (@$expected), but got $got",caller=>\@caller,expected=>$expected,got=>$args{got},)}sub cb_tag {my ($self,$token)=@_;my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];my$tag=$self->_read_tag($token->{value},$self->tagmap);$last->{inline}||= [];push @{$last->{inline}},{type=>'tag',value=>$tag,offset=>$token->{column},}}sub _read_tag {my ($self,$tag,$map)=@_;if ($tag eq '!'){return "!"}elsif ($tag =~ m/^!<(.*)>/){return $1}elsif ($tag =~ m/^(![^!]*!|!)(.+)/){my$alias=$1;my$name=$2;$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;if (exists$map->{$alias }){$tag=$map->{$alias }.$name}else {if ($alias ne '!' and $alias ne '!!'){die "Found undefined tag handle '$alias'"}$tag="!$name"}}else {die "Invalid tag"}return$tag}sub cb_anchor {my ($self,$token)=@_;my$anchor=$token->{value};$anchor=substr($anchor,1);my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];$last->{inline}||= [];push @{$last->{inline}},{type=>'anchor',value=>$anchor,offset=>$token->{column},}}sub cb_property_eol {my ($self,$res)=@_;my$stack=$self->event_stack;my$last=$stack->[-1]->[1];my$inline=delete$last->{inline}or return;my$newline=$last->{newline}||= [];push @$newline,@$inline}sub cb_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_send_mapkey {my ($self,$res)=@_;my$last=pop @{$self->event_stack};$self->scalar_event($last->[1]);$self->set_new_node(1)}sub cb_send_scalar {my ($self,$res)=@_;my$last=pop @{$self->event_stack};return unless$last;$self->scalar_event($last->[1]);my$e=$self->events;if ($e->[-1]eq 'IMAP'){$self->end_flow_mapping}}sub cb_empty_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_flow_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias_key {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias });$self->set_new_node(1)}sub cb_send_alias_from_stack {my ($self,$token)=@_;my$last=pop @{$self->event_stack};$self->alias_event($last->[1])}sub cb_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);push @{$self->event_stack},[alias=>{value=>$alias,offset=>$token->{column},}]}sub cb_question {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_flow_question {my ($self,$res)=@_;$self->set_new_node(2)}sub cb_empty_complexvalue {my ($self,$res)=@_;$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}sub cb_questionstart {my ($self,$token)=@_;$self->start_mapping($token->{column})}sub cb_complexcolon {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_seqstart {my ($self,$token)=@_;my$column=$token->{column};$self->start_sequence($column);$self->set_new_node(1)}sub cb_seqitem {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_take_quoted {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_quoted_multiline {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_take_quoted_key {my ($self,$token)=@_;$self->cb_take_quoted($token);$self->cb_send_mapkey}sub cb_send_plain_multi {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_start_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_start_flowseq {my ($self,$token)=@_;$self->start_flow_sequence($token->{column})}sub cb_start_flowmap {my ($self,$token)=@_;$self->start_flow_mapping($token->{column})}sub cb_end_flowseq {my ($self,$res)=@_;$self->cb_send_scalar;$self->end_flow_sequence;$self->set_new_node(0)}sub cb_flow_comma {my ($self)=@_;my$event_types=$self->events;$self->set_new_node(0);if ($event_types->[-1]=~ m/^FLOWSEQ/){$self->cb_send_scalar;$event_types->[-1]=$next_event{$event_types->[-1]}}}sub cb_flow_colon {my ($self)=@_;$self->set_new_node(1)}sub cb_empty_flow_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_end_flowmap {my ($self,$res)=@_;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_end_flowmap_empty {my ($self,$res)=@_;$self->cb_empty_flowmap_value;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_flowkey_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_flowkey_quoted {my ($self,$token)=@_;my$stack=$self->event_stack;my$subtokens=$token->{subtokens};my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowmap_key_value {my ($self,$token)=@_;$self->cb_empty_flow_mapkey($token);$self->cb_empty_flowmap_value;$self->cb_flow_comma}sub cb_end_empty_flowmap_key_value {my ($self,$token)=@_;$self->cb_empty_flow_mapkey($token);$self->cb_empty_flowmap_value;$self->cb_flow_comma;$self->cb_end_flowmap}sub cb_empty_flowmap_value {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowseq_comma {my ($self,$token)=@_;$self->cb_empty_flowmap_value($token);$self->cb_flow_comma}sub cb_empty_flowseq_end {my ($self,$token)=@_;$self->cb_empty_flowmap_value($token);$self->cb_end_flowseq}sub cb_insert_map_alias {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->alias_event($info);$self->set_new_node(1)}sub cb_insert_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_implicit_flowseq_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_flow_mapping($info->{offset},1);$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_empty_implicit_flowseq_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_flow_mapping($info->{offset},1);$self->cb_empty_flowmap_value;$self->set_new_node(2)}sub cb_insert_empty_map {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_block_scalar {my ($self,$token)=@_;my$type=$token->{subtokens}->[0]->{value};my$stack=$self->event_stack;my$info={style=>$type eq '|' ? YAML_LITERAL_SCALAR_STYLE : YAML_FOLDED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$self->event_stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_end_document {my ($self,$token)=@_;$self->end_document(0)}sub cb_end_document_empty {my ($self,$token)=@_;$self->end_document(0)}sub cb_doc_start_implicit {my ($self,$token)=@_;$self->start_document(1)}sub cb_doc_start_explicit {my ($self,$token)=@_;$self->start_document(0)}sub cb_end_doc_start_document {my ($self,$token)=@_;$self->end_document(1);$self->start_document(0)}sub cb_tag_directive {my ($self,$token)=@_;my ($name,$tag_alias,$tag_url)=split ' ',$token->{value};$self->tagmap->{$tag_alias }=$tag_url}sub cb_reserved_directive {}sub cb_set_yaml_version_directive {my ($self,$token)=@_;if ($self->yaml_version_directive){croak "Found duplicate YAML directive"}my ($version)=$token->{value}=~ m/^%YAML[ \t]+(1\.[12])/;$self->set_yaml_version($version || '1.2');$self->set_yaml_version_directive(1)}1;
YAML_PP_PARSER

$fatpacked{"YAML/PP/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PERL';
  use strict;use warnings;package YAML::PP::Perl;our$VERSION='0.036';use base 'Exporter';use base 'YAML::PP';our@EXPORT_OK=qw/Load Dump LoadFile DumpFile/;use YAML::PP;use YAML::PP::Schema::Perl;sub new {my ($class,%args)=@_;$args{schema}||= [qw/Core Perl/];$class->SUPER::new(%args)}sub Load {my ($yaml)=@_;__PACKAGE__->new->load_string($yaml)}sub LoadFile {my ($file)=@_;__PACKAGE__->new->load_file($file)}sub Dump {my (@data)=@_;__PACKAGE__->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;__PACKAGE__->new->dump_file($file,@data)}1;
YAML_PP_PERL

$fatpacked{"YAML/PP/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_READER';
  use strict;use warnings;package YAML::PP::Reader;our$VERSION='0.036';sub input {return $_[0]->{input}}sub set_input {$_[0]->{input}=$_[1]}sub new {my ($class,%args)=@_;my$input=delete$args{input};return bless {input=>$input,},$class}sub read {my ($self)=@_;my$pos=pos$self->{input}|| 0;my$yaml=substr($self->{input},$pos);$self->{input}='';return$yaml}sub readline {my ($self)=@_;unless (length$self->{input}){return}if ($self->{input}=~ m/\G([^\r\n]*(?:\n|\r\n|\r|\z))/g){my$line=$1;unless (length$line){$self->{input}='';return}return$line}return}package YAML::PP::Reader::File;use Scalar::Util qw/openhandle/;our@ISA=qw/YAML::PP::Reader/;use Carp qw/croak/;sub open_handle {if (openhandle($_[0]->{input})){return $_[0]->{input}}open my$fh,'<:encoding(UTF-8)',$_[0]->{input}or croak "Could not open '$_[0]->{input}' for reading: $!";return$fh}sub read {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;if (wantarray){my@yaml=<$fh>;return@yaml}else {local $/;my$yaml=<$fh>;return$yaml}}sub readline {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;return scalar <$fh>}1;
YAML_PP_READER

$fatpacked{"YAML/PP/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_RENDER';
  use strict;use warnings;package YAML::PP::Render;our$VERSION='0.036';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;sub render_quoted {my ($self,$style,$lines)=@_;my$quoted='';my$addspace=0;for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$value=$line->{value};my$last=$i==$#$lines;my$first=$i==0;if ($value eq ''){if ($first){$addspace=1}elsif ($last){$quoted .= ' ' if$addspace}else {$addspace=0;$quoted .= "\n"}next}$quoted .= ' ' if$addspace;$addspace=1;if ($style eq '"'){if ($line->{orig}=~ m/\\$/){$line->{value}=~ s/\\$//;$value =~ s/\\$//;$addspace=0}}$quoted .= $value}return$quoted}sub render_block_scalar {my ($self,$block_type,$chomp,$lines)=@_;my ($folded,$keep,$trim);if ($block_type eq '>'){$folded=1}if ($chomp eq '+'){$keep=1}elsif ($chomp eq '-'){$trim=1}my$string='';if (not $keep){while (@$lines){last if$lines->[-1]ne '';pop @$lines}}if ($folded){my$prev='START';my$trailing='';if ($keep){while (@$lines and $lines->[-1]eq ''){pop @$lines;$trailing .= "\n"}}for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$type=$line eq '' ? 'EMPTY' : $line =~ m/\A[ \t]/ ? 'MORE' : 'CONTENT';if ($prev eq 'MORE' and $type eq 'EMPTY'){$type='MORE'}elsif ($prev eq 'CONTENT'){if ($type ne 'CONTENT'){$string .= "\n"}elsif ($type eq 'CONTENT'){$string .= ' '}}elsif ($prev eq 'START' and $type eq 'EMPTY'){$string .= "\n";$type='START'}elsif ($prev eq 'EMPTY' and $type ne 'CONTENT'){$string .= "\n"}$string .= $line;if ($type eq 'MORE' and $i < $#$lines){$string .= "\n"}$prev=$type}if ($keep){$string .= $trailing}$string .= "\n" if @$lines and not $trim}else {for my$i (0 .. $#$lines){$string .= $lines->[$i ];$string .= "\n" if ($i!=$#$lines or not $trim)}}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$string],['string']);return$string}sub render_multi_val {my ($self,$multi)=@_;my$string='';my$start=1;for my$line (@$multi){if (not $start){if ($line eq ''){$string .= "\n";$start=1}else {$string .= " $line"}}else {$string .= $line;$start=0}}return$string}1;
YAML_PP_RENDER

$fatpacked{"YAML/PP/Representer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_REPRESENTER';
  use strict;use warnings;package YAML::PP::Representer;our$VERSION='0.036';use Scalar::Util qw/reftype blessed refaddr/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use B;sub new {my ($class,%args)=@_;my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$self=bless {schema=>delete$args{schema},preserve=>$preserve,},$class;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,preserve=>$self->{preserve},};return bless$clone,ref$self}sub schema {return $_[0]->{schema}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub represent_node {my ($self,$node)=@_;my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if ($preserve_style or $preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){my$value=$node->{value}->value;if ($preserve_style){$node->{style}=$node->{value}->style}$node->{value}=$value}}$node->{reftype}=reftype($node->{value});if (not $node->{reftype}and reftype(\$node->{value})eq 'GLOB'){$node->{reftype}='GLOB'}if ($node->{reftype}){$self->_represent_noderef($node)}else {$self->_represent_node_nonref($node)}$node->{reftype}=(reftype$node->{data})|| '';if ($node->{reftype}eq 'HASH' and my$tied=tied(%{$node->{data}})){my$representers=$self->schema->representers;$tied=ref$tied;if (my$def=$representers->{tied_equals}->{$tied }){my$code=$def->{code};my$done=$code->($self,$node)}}if ($node->{reftype}eq 'HASH'){unless (defined$node->{items}){my@keys;if ($self->preserve_order){@keys=keys %{$node->{data}}}else {@keys=sort keys %{$node->{data}}}for my$key (@keys){push @{$node->{items}},$key,$node->{data}->{$key }}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){$args{style}=$tied->{style}}}return [mapping=>$node,%args ]}elsif ($node->{reftype}eq 'ARRAY'){unless (defined$node->{items}){@{$node->{items}}=@{$node->{data}}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){$args{style}=$tied->{style}}}return [sequence=>$node,%args ]}elsif ($node->{reftype}){die "Cannot handle reftype '$node->{reftype}' (you might want to enable YAML::PP::Schema::Perl)"}else {unless (defined$node->{items}){$node->{items}=[$node->{data}]}return [scalar=>$node ]}}my$bool_code=<<'EOM';my$is_bool;sub _represent_node_nonref {my ($self,$node)=@_;my$representers=$self->schema->representers;if (not defined$node->{value}){if (my$undef=$representers->{undef}){return 1 if$undef->($self,$node)}else {$node->{style}=YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}='';return 1}}if ($] >= 5.036000 and my$rep=$representers->{bool}){$is_bool ||= eval$bool_code;if ($is_bool->($node->{value})){return$rep->{code}->($self,$node)}}for my$rep (@{$representers->{flags}}){my$check_flags=$rep->{flags};my$flags=B::svref_2object(\$node->{value})->FLAGS;if ($flags & $check_flags){return 1 if$rep->{code}->($self,$node)}}if (my$rep=$representers->{equals}->{$node->{value}}){return 1 if$rep->{code}->($self,$node)}for my$rep (@{$representers->{regex}}){if ($node->{value}=~ $rep->{regex}){return 1 if$rep->{code}->($self,$node)}}unless (defined$node->{data}){$node->{data}=$node->{value}}unless (defined$node->{style}){$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{style}=""}}sub _represent_noderef {my ($self,$node)=@_;my$representers=$self->schema->representers;if (my$classname=blessed($node->{value})){if (my$def=$representers->{class_equals}->{$classname }){my$code=$def->{code};return 1 if$code->($self,$node)}for my$matches (@{$representers->{class_matches}}){my ($re,$code)=@$matches;if (ref$re and $classname =~ $re or $re){return 1 if$code->($self,$node)}}for my$isa (@{$representers->{class_isa}}){my ($class_name,$code)=@$isa;if ($node->{value }->isa($class_name)){return 1 if$code->($self,$node)}}}if ($node->{reftype}eq 'SCALAR' and my$scalarref=$representers->{scalarref}){my$code=$scalarref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'REF' and my$refref=$representers->{refref}){my$code=$refref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'CODE' and my$coderef=$representers->{coderef}){my$code=$coderef->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'GLOB' and my$glob=$representers->{glob}){my$code=$glob->{code};return 1 if$code->($self,$node)}$node->{data}=$node->{value}}1;
  sub {
      my ($x) = @_;
      use experimental qw/ builtin /;
      builtin::is_bool($x);
  }
  EOM
YAML_PP_REPRESENTER

$fatpacked{"YAML/PP/Schema.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA';
  use strict;use warnings;package YAML::PP::Schema;use B;use Module::Load qw//;our$VERSION='0.036';use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;use Scalar::Util qw/blessed/;sub new {my ($class,%args)=@_;my$yaml_version=delete$args{yaml_version};my$bool=delete$args{boolean};$bool='perl' unless defined$bool;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$true;my$false;my@bool_class;my@bools=split m/,/,$bool;for my$b (@bools){if ($b eq '*'){push@bool_class,('boolean','JSON::PP::Boolean');last}elsif ($b eq 'JSON::PP'){require JSON::PP;$true ||= \&_bool_jsonpp_true;$false ||= \&_bool_jsonpp_false;push@bool_class,'JSON::PP::Boolean'}elsif ($b eq 'boolean'){require boolean;$true ||= \&_bool_booleanpm_true;$false ||= \&_bool_booleanpm_false;push@bool_class,'boolean'}elsif ($b eq 'perl'){$true ||= \&_bool_perl_true;$false ||= \&_bool_perl_false}elsif ($b eq 'perl_experimental'){$true ||= \&_bool_perl_true;$false ||= \&_bool_perl_false;push@bool_class,'perl_experimental'}else {die "Invalid value for 'boolean': '$b'. Allowed: ('perl', 'boolean', 'JSON::PP')"}}my%representers=('undef'=>undef,flags=>[],equals=>{},regex=>[],class_equals=>{},class_matches=>[],class_isa=>[],scalarref=>undef,refref=>undef,coderef=>undef,glob=>undef,tied_equals=>{},);my$self=bless {yaml_version=>$yaml_version,resolvers=>{},representers=>\%representers,true=>$true,false=>$false,bool_class=>\@bool_class,},$class;return$self}sub resolvers {return $_[0]->{resolvers}}sub representers {return $_[0]->{representers}}sub true {return $_[0]->{true}}sub false {return $_[0]->{false}}sub bool_class {return @{$_[0]->{bool_class}}? $_[0]->{bool_class}: undef}sub yaml_version {return $_[0]->{yaml_version}}my%LOADED_SCHEMA=(JSON=>1,);my%DEFAULT_SCHEMA=('1.2'=>'Core','1.1'=>'YAML1_1',);sub load_subschemas {my ($self,@schemas)=@_;my$yaml_version=$self->yaml_version;my$i=0;while ($i < @schemas){my$item=$schemas[$i ];if ($item eq '+'){$item=$DEFAULT_SCHEMA{$yaml_version }}$i++;if (blessed($item)){$item->register(schema=>$self,);next}my@options;while ($i < @schemas and ($schemas[$i ]=~ m/^[^A-Za-z]/ or $schemas[$i ]=~ m/^[a-zA-Z0-9]+=/)){push@options,$schemas[$i ];$i++}my$class;if ($item =~ m/^\:(.*)/){$class="$1";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}Module::Load::load$class}else {$class="YAML::PP::Schema::$item";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}$LOADED_SCHEMA{$item }||= Module::Load::load$class}$class->register(schema=>$self,options=>\@options,)}}sub add_resolver {my ($self,%args)=@_;my$tag=$args{tag};my$rule=$args{match};my$resolvers=$self->resolvers;my ($type,@rule)=@$rule;my$implicit=$args{implicit};$implicit=1 unless defined$implicit;my$resolver_list=[];if ($tag){if (ref$tag eq 'Regexp'){my$res=$resolvers->{tags}||= [];push @$res,[$tag,{}];push @$resolver_list,$res->[-1]->[1]}else {my$res=$resolvers->{tag}->{$tag }||= {};push @$resolver_list,$res}}if ($implicit){push @$resolver_list,$resolvers->{value}||= {}}for my$res (@$resolver_list){if ($type eq 'equals'){my ($match,$value)=@rule;unless (exists$res->{equals}->{$match }){$res->{equals}->{$match }=$value}next}elsif ($type eq 'regex'){my ($match,$value)=@rule;push @{$res->{regex}},[$match=>$value ]}elsif ($type eq 'all'){my ($value)=@rule;$res->{all}=$value}}}sub add_sequence_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(sequence=>%args)}sub add_mapping_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(mapping=>%args)}sub add_collection_resolver {my ($self,$type,%args)=@_;my$tag=$args{tag};my$implicit=$args{implicit};my$resolvers=$self->resolvers;if ($tag and ref$tag eq 'Regexp'){my$res=$resolvers->{$type }->{tags}||= [];push @$res,[$tag,{on_create=>$args{on_create},on_data=>$args{on_data},}]}elsif ($tag){my$res=$resolvers->{$type }->{tag}->{$tag }||= {on_create=>$args{on_create},on_data=>$args{on_data},}}}sub add_representer {my ($self,%args)=@_;my$representers=$self->representers;if (my$flags=$args{flags}){my$rep=$representers->{flags};push @$rep,\%args;return}if (my$regex=$args{regex}){my$rep=$representers->{regex};push @$rep,\%args;return}if (my$regex=$args{class_matches}){my$rep=$representers->{class_matches};push @$rep,[$args{class_matches},$args{code}];return}if (my$class_equals=$args{class_equals}){if ($] >= 5.036000 and $class_equals eq 'perl_experimental'){$representers->{bool}={code=>$args{code},};return}my$rep=$representers->{class_equals};$rep->{$class_equals }={code=>$args{code},};return}if (my$class_isa=$args{class_isa}){my$rep=$representers->{class_isa};push @$rep,[$args{class_isa},$args{code}];return}if (my$tied_equals=$args{tied_equals}){my$rep=$representers->{tied_equals};$rep->{$tied_equals }={code=>$args{code},};return}if (defined(my$equals=$args{equals})){my$rep=$representers->{equals};$rep->{$equals }={code=>$args{code},};return}if (defined(my$scalarref=$args{scalarref})){$representers->{scalarref}={code=>$args{code},};return}if (defined(my$refref=$args{refref})){$representers->{refref}={code=>$args{code},};return}if (defined(my$coderef=$args{coderef})){$representers->{coderef}={code=>$args{code},};return}if (defined(my$glob=$args{glob})){$representers->{glob}={code=>$args{code},};return}if (my$undef=$args{undefined}){$representers->{undef}=$undef;return}}sub load_scalar {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$value=$event->{value};my$resolvers=$self->resolvers;my$res;if ($tag){$res=$resolvers->{tag}->{$tag };if (not $res and my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$rule)=@$match;if ($tag =~ $re){$res=$rule;last}}}}else {$res=$resolvers->{value};if ($event->{style}ne YAML_PLAIN_SCALAR_STYLE){return$value}}if (my$equals=$res->{equals}){if (exists$equals->{$value }){my$res=$equals->{$value };if (ref$res eq 'CODE'){return$res->($constructor,$event)}return$res}}if (my$regex=$res->{regex}){for my$item (@$regex){my ($re,$sub)=@$item;my@matches=$value =~ $re;if (@matches){return$sub->($constructor,$event,\@matches)}}}if (my$catch_all=$res->{all}){if (ref$catch_all eq 'CODE'){return$catch_all->($constructor,$event)}return$catch_all}return$value}sub create_sequence {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data=[];my$on_data;my$resolvers=$self->resolvers->{sequence};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub create_mapping {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data={};my$on_data;my$resolvers=$self->resolvers->{mapping};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub _bool_jsonpp_true {JSON::PP::true()}sub _bool_booleanpm_true {boolean::true()}sub _bool_perl_true {!!1}sub _bool_jsonpp_false {JSON::PP::false()}sub _bool_booleanpm_false {boolean::false()}sub _bool_perl_false {!!0}1;
YAML_PP_SCHEMA

$fatpacked{"YAML/PP/Schema/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_BINARY';
  use strict;use warnings;package YAML::PP::Schema::Binary;our$VERSION='0.036';use MIME::Base64 qw/decode_base64 encode_base64/;use YAML::PP::Common qw/YAML_ANY_SCALAR_STYLE/;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:binary',match=>[all=>sub {my ($constructor,$event)=@_;my$base64=$event->{value};my$binary=decode_base64($base64);return$binary}],implicit=>0,);$schema->add_representer(regex=>qr{.*},code=>sub {my ($rep,$node)=@_;my$binary=$node->{value};unless ($binary =~ m/[\x{7F}-\x{10FFFF}]/){return}if (utf8::is_utf8($binary)){return}my$base64=encode_base64($binary);$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{data}=$base64;$node->{tag}="tag:yaml.org,2002:binary";return 1},)}1;
YAML_PP_SCHEMA_BINARY

$fatpacked{"YAML/PP/Schema/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_CORE';
  use strict;use warnings;package YAML::PP::Schema::Core;our$VERSION='0.036';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_CORE=qr{^([+-]?(?:[0-9]+))$};my$RE_FLOAT_CORE=qr{^([+-]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][+-]?[0-9]+)?)$};my$RE_INT_OCTAL=qr{^0o([0-7]+)$};my$RE_INT_HEX=qr{^0x([0-9a-fA-F]+)$};sub _from_oct {oct $_[2]->[0]}sub _from_hex {hex $_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_CORE=>\&YAML::PP::Schema::JSON::_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_CORE=>\&YAML::PP::Schema::JSON::_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True false FALSE False null NULL Null ~ .inf .Inf .INF +.inf +.Inf +.INF -.inf -.Inf -.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_CORE|$RE_FLOAT_CORE|$RE_INT_OCTAL|$RE_INT_HEX},code=>\&represent_literal,);if ($schema->bool_class){for my$class (@{$schema->bool_class}){$schema->add_representer(class_equals=>$class,code=>\&represent_bool,)}}return}1;
YAML_PP_SCHEMA_CORE

$fatpacked{"YAML/PP/Schema/Failsafe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_FAILSAFE';
  use strict;use warnings;package YAML::PP::Schema::Failsafe;our$VERSION='0.036';sub register {my ($self,%args)=@_;return}1;
YAML_PP_SCHEMA_FAILSAFE

$fatpacked{"YAML/PP/Schema/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_INCLUDE';
  use strict;use warnings;package YAML::PP::Schema::Include;our$VERSION='0.036';use Carp qw/croak/;use Scalar::Util qw/weaken/;use File::Basename qw/dirname/;sub new {my ($class,%args)=@_;my$paths=delete$args{paths};if (defined$paths){unless (ref$paths eq 'ARRAY'){$paths=[$paths]}}else {$paths=[]}my$allow_absolute=$args{allow_absolute}|| 0;my$loader=$args{loader}|| \&default_loader;my$self=bless {paths=>$paths,allow_absolute=>$allow_absolute,last_includes=>[],cached=>{},loader=>$loader,},$class;return$self}sub init {my ($self)=@_;$self->{last_includes}=[];$self->{cached}=[]}sub paths {$_[0]->{paths}}sub allow_absolute {$_[0]->{allow_absolute}}sub yp {my ($self,$yp)=@_;if (@_==2){$self->{yp}=$yp;weaken$self->{yp};return$yp}return$self->{yp}}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'!include',match=>[all=>sub {$self->include(@_)}],implicit=>0,)}sub include {my ($self,$constructor,$event)=@_;my$yp=$self->yp;my$search_paths=$self->paths;my$allow_absolute=$self->allow_absolute;my$relative=not @$search_paths;if ($relative){my$last_includes=$self->{last_includes};if (@$last_includes){$search_paths=[$last_includes->[-1]]}else {my$filename=$yp->loader->filename;$search_paths=[dirname$filename]}}my$filename=$event->{value};my$fullpath;if (File::Spec->file_name_is_absolute($filename)){unless ($allow_absolute){croak "Absolute filenames not allowed"}$fullpath=$filename}else {my@paths=File::Spec->splitdir($filename);unless ($allow_absolute){@paths=File::Spec->no_upwards(@paths)}for my$candidate (@$search_paths){my$test=File::Spec->catfile($candidate,@paths);if (-e $test){$fullpath=$test;last}}croak "File '$filename' not found" unless defined$fullpath}if ($self->{cached}->{$fullpath }++){croak "Circular include '$fullpath'"}if ($relative){push @{$self->{last_includes}},dirname$fullpath}my$clone=$yp->clone;my ($data)=$self->loader->($clone,$fullpath);if ($relative){pop @{$self->{last_includes}}}unless (--$self->{cached}->{$fullpath }){delete$self->{cached}->{$fullpath }}return$data}sub loader {my ($self,$code)=@_;if (@_==2){$self->{loader}=$code;return$code}return$self->{loader}}sub default_loader {my ($yp,$filename)=@_;$yp->load_file($filename)}1;
YAML_PP_SCHEMA_INCLUDE

$fatpacked{"YAML/PP/Schema/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_JSON';
  use strict;use warnings;package YAML::PP::Schema::JSON;our$VERSION='0.036';use base 'Exporter';our@EXPORT_OK=qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use Carp qw/croak/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE/;my$RE_INT=qr{^(-?(?:0|[1-9][0-9]*))$};my$RE_FLOAT=qr{^(-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)$};sub _to_int {0 + $_[2]->[0]}sub _to_float {unpack F=>pack F=>$_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$options=$args{options};my$empty_null=0;for my$opt (@$options){if ($opt eq 'empty=str'){}elsif ($opt eq 'empty=null'){$empty_null=1}else {croak "Invalid option for JSON Schema: '$opt'"}}$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>null=>undef ],);if ($empty_null){$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>''=>undef ],implicit=>1,)}else {$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[equals=>''=>'' ],implicit=>1,)}$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>true=>$schema->true ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>false=>$schema->false ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);$schema->add_representer(undefined=>\&represent_undef,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true false null/);$schema->add_representer(regex=>qr{$RE_INT|$RE_FLOAT},code=>\&represent_literal,);if ($schema->bool_class){for my$class (@{$schema->bool_class}){$schema->add_representer(class_equals=>$class,code=>\&represent_bool,)}}return}sub represent_undef {my ($rep,$node)=@_;$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}='null';return 1}sub represent_literal {my ($rep,$node)=@_;$node->{style}||= YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_int {my ($rep,$node)=@_;if (int($node->{value})ne $node->{value}){return 0}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');sub represent_float {my ($rep,$node)=@_;if (exists$special{$node->{value}}){$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}=$special{$node->{value}};return 1}if (0.0 + $node->{value}ne $node->{value}){return 0}if (int($node->{value})eq $node->{value}and not $node->{value}=~ m/\./){$node->{value}.= '.0'}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_bool {my ($rep,$node)=@_;my$string=$node->{value}? 'true' : 'false';$node->{style}=YAML_PLAIN_SCALAR_STYLE;@{$node->{items}}=$string;$node->{data}=$string;return 1}1;
YAML_PP_SCHEMA_JSON

$fatpacked{"YAML/PP/Schema/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_MERGE';
  use strict;use warnings;package YAML::PP::Schema::Merge;our$VERSION='0.036';use YAML::PP::Type::MergeKey;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:merge',match=>[equals=>'<<'=>YAML::PP::Type::MergeKey->new ],)}1;
YAML_PP_SCHEMA_MERGE

$fatpacked{"YAML/PP/Schema/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_PERL';
  use strict;use warnings;package YAML::PP::Schema::Perl;our$VERSION='0.036';use Scalar::Util qw/blessed reftype/;my$qr_prefix;{$qr_prefix=qr{\(\?-xism\:};if ($] >= 5.014){$qr_prefix=qr{\(\?\^(?:[uadl])?\:}}}sub new {my ($class,%args)=@_;my$tags=$args{tags}|| [];my$loadcode=$args{loadcode}|| 0;my$dumpcode=$args{dumpcode};$dumpcode=1 unless defined$dumpcode;my$classes=$args{classes};my$self=bless {tags=>$tags,loadcode=>$loadcode,dumpcode=>$dumpcode,classes=>$classes,},$class}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$tags;my$loadcode=0;my$dumpcode=1;my$classes;if (blessed($self)){$tags=$self->{tags};@$tags=('!perl')unless @$tags;$loadcode=$self->{loadcode};$dumpcode=$self->{dumpcode};$classes=$self->{classes}}else {my$options=$args{options};my$tagtype='!perl';for my$option (@$options){if ($option =~ m/^tags?=(.+)$/){$tagtype=$1}elsif ($option eq '+loadcode'){$loadcode=1}elsif ($option eq '-dumpcode'){$dumpcode=0}}$tags=[split m/\+/,$tagtype]}my$perl_tag;my%tagtypes;my@perl_tags;for my$type (@$tags){if ($type eq '!perl'){$perl_tag ||= $type;push@perl_tags,'!perl'}elsif ($type eq '!!perl'){$perl_tag ||= 'tag:yaml.org,2002:perl';push@perl_tags,'tag:yaml.org,2002:perl'}else {die "Invalid tagtype '$type'"}$tagtypes{$type }=1}my$perl_regex='!perl';if ($tagtypes{'!perl'}and $tagtypes{'!!perl'}){$perl_regex='(?:tag:yaml\\.org,2002:|!)perl'}elsif ($tagtypes{'!perl'}){$perl_regex='!perl'}elsif ($tagtypes{'!!perl'}){$perl_regex='tag:yaml\\.org,2002:perl'}my$class_regex=qr{.+};my$no_objects=0;if ($classes){if (@$classes){$class_regex='(' .join('|',map "\Q$_\E",@$classes).')'}else {$no_objects=1;$class_regex=''}}if ($loadcode){my$load_code=sub {my ($constructor,$event)=@_;return$self->evaluate_code($event->{value})};my$load_code_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};my$sub=$self->evaluate_code($event->{value});return$self->object($sub,$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$load_code],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$load_code_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$load_code ],implicit=>0,)if$no_objects}else {my$loadcode_dummy=sub {return sub {}};my$loadcode_blessed_dummy=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};return$self->object(sub {},$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$loadcode_dummy ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$loadcode_blessed_dummy ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$loadcode_dummy ],implicit=>0,)if$no_objects}my$load_glob=sub {my$value=undef;return \$value};my$load_glob_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/glob:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/glob",on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)for@perl_tags;if ($no_objects){$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:.+$},on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)}else {$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:$class_regex$},on_create=>$load_glob_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_glob($list)},)}my$load_regex=sub {my ($constructor,$event)=@_;return$self->construct_regex($event->{value})};my$load_regex_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/regexp:}{};my$qr=$self->construct_regex($event->{value});return$self->object($qr,$class)};$schema->add_resolver(tag=>"$_/regexp",match=>[all=>$load_regex ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex ],implicit=>0,)if$no_objects;my$load_sequence=sub {return []};my$load_sequence_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/array:}{};return$self->object([],$class)};$schema->add_sequence_resolver(tag=>"$_/array",on_create=>$load_sequence,)for@perl_tags;$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:$class_regex$},on_create=>$load_sequence_blessed,);$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:.+$},on_create=>$load_sequence,)if$no_objects;my$load_mapping=sub {return {}};my$load_mapping_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/hash:}{};return$self->object({},$class)};$schema->add_mapping_resolver(tag=>"$_/hash",on_create=>$load_mapping,)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:$class_regex$},on_create=>$load_mapping_blessed,);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:.+$},on_create=>$load_mapping,)if$no_objects;my$load_ref=sub {my$value=undef;return \$value};my$load_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/ref:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/ref",on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:$class_regex$},on_create=>$load_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:.+$},on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)if$no_objects;my$load_scalar_ref=sub {my$value=undef;return \$value};my$load_scalar_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/scalar:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/scalar",on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:$class_regex$},on_create=>$load_scalar_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:.+$},on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)if$no_objects;$schema->add_representer(scalarref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/scalar";$node->{data}=$self->represent_scalar($node->{value})},);$schema->add_representer(refref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/ref";$node->{data}=$self->represent_ref($node->{value})},);$schema->add_representer(coderef=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/code";$node->{data}=$dumpcode ? $self->represent_code($node->{value}): '{ "DUMMY" }'},);$schema->add_representer(glob=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/glob";$node->{data}=$self->represent_glob($node->{value})},);$schema->add_representer(class_matches=>1,code=>sub {my ($rep,$node)=@_;my$blessed=blessed$node->{value};my$tag_blessed=":$blessed";if ($blessed !~ m/^$class_regex$/){$tag_blessed=''}$node->{tag}=sprintf "$perl_tag/%s%s",lc($node->{reftype}),$tag_blessed;if ($node->{reftype}eq 'HASH'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'ARRAY'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'REGEXP'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag ."/regexp"}$node->{data}=$self->represent_regex($node->{value})}elsif ($node->{reftype}eq 'SCALAR'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag .'/regexp';$node->{data}=$self->represent_regex($node->{value})}elsif ($] <= 5.010001 and not defined ${$node->{value}}and $node->{value}=~ m/^\(\?/){$node->{tag}=$perl_tag .'/regexp' .$tag_blessed;$node->{data}=$self->represent_regex($node->{value})}else {$node->{data}=$self->represent_scalar($node->{value})}}elsif ($node->{reftype}eq 'REF'){$node->{data}=$self->represent_ref($node->{value})}elsif ($node->{reftype}eq 'CODE'){$node->{data}=$dumpcode ? $self->represent_code($node->{value}): '{ "DUMMY" }'}elsif ($node->{reftype}eq 'GLOB'){$node->{data}=$self->represent_glob($node->{value})}else {die "Reftype '$node->{reftype}' not implemented"}return 1},);return}sub evaluate_code {my ($self,$code)=@_;unless ($code =~ m/^ \s* \{ .* \} \s* \z/xs){die "Malformed code"}$code="sub $code";my$sub=eval$code;if ($@){die "Couldn't eval code: $@>>$code<<"}return$sub}sub construct_regex {my ($self,$regex)=@_;if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}my$qr=qr{$regex};return$qr}sub construct_glob {my ($self,$list)=@_;if (@$list % 2){die "Unexpected data in perl/glob construction"}my%globdata=@$list;my$name=delete$globdata{NAME}or die "Missing NAME in perl/glob";my$pkg=delete$globdata{PACKAGE};$pkg='main' unless defined$pkg;my@allowed=qw(SCALAR ARRAY HASH CODE IO);delete@globdata{@allowed };if (my@keys=keys%globdata){die "Unexpected keys in perl/glob: @keys"}no strict 'refs';return *{"${pkg}::$name"}}sub construct_scalar {my ($self,$list)=@_;if (@$list!=2){die "Unexpected data in perl/scalar construction"}my ($key,$value)=@$list;unless ($key eq '='){die "Unexpected data in perl/scalar construction"}return$value}sub construct_ref {&construct_scalar}sub represent_scalar {my ($self,$value)=@_;return {'='=>$$value }}sub represent_ref {&represent_scalar}sub represent_code {my ($self,$code)=@_;require B::Deparse;my$deparse=B::Deparse->new("-p","-sC");return$deparse->coderef2text($code)}my@stats=qw/device inode mode links uid gid rdev size atime mtime ctime blksize blocks/;sub represent_glob {my ($self,$glob)=@_;my%glob;for my$type (qw/PACKAGE NAME SCALAR ARRAY HASH CODE IO/){my$value=*{$glob}{$type};if ($type eq 'SCALAR'){$value=$$value}elsif ($type eq 'IO'){if (defined$value){undef$value;$value->{stat}={};if ($value->{fileno}=fileno(*{$glob})){@{$value->{stat}}{@stats }=stat(*{$glob});$value->{tell}=tell *{$glob}}}}$glob{$type }=$value if defined$value}return \%glob}sub represent_regex {my ($self,$regex)=@_;$regex="$regex";if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}return$regex}sub object {my ($self,$data,$class)=@_;return bless$data,$class}1;
YAML_PP_SCHEMA_PERL

$fatpacked{"YAML/PP/Schema/Tie/IxHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_TIE_IXHASH';
  use strict;use warnings;package YAML::PP::Schema::Tie::IxHash;our$VERSION='0.036';use base 'YAML::PP::Schema';use Scalar::Util qw/blessed reftype/;my$ixhash=eval {require Tie::IxHash};sub register {my ($self,%args)=@_;my$schema=$args{schema};unless ($ixhash){die "You need to install Tie::IxHash in order to use this module"}$schema->add_representer(tied_equals=>'Tie::IxHash',code=>sub {my ($rep,$node)=@_;$node->{items}=[%{$node->{data}}];return 1},);return}1;
YAML_PP_SCHEMA_TIE_IXHASH

$fatpacked{"YAML/PP/Schema/YAML1_1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_YAML1_1';
  use strict;use warnings;package YAML::PP::Schema::YAML1_1;our$VERSION='0.036';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_1_1=qr{^([+-]?(?:0|[1-9][0-9_]*))$};my$RE_FLOAT_1_1=qr{^([+-]?(?:[0-9][0-9_]*)?\.[0-9_]*(?:[eE][+-][0-9]+)?)$};my$RE_SEXAGESIMAL=qr{^([+-]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]*)$};my$RE_SEXAGESIMAL_INT=qr{^([-+]?[1-9][0-9_]*(:[0-5]?[0-9])+)$};my$RE_INT_OCTAL_1_1=qr{^([+-]?)0([0-7_]+)$};my$RE_INT_HEX_1_1=qr{^([+-]?)(0x[0-9a-fA-F_]+)$};my$RE_INT_BIN_1_1=qr{^([-+]?)(0b[0-1_]+)$};sub _from_oct {my ($constructor,$event,$matches)=@_;my ($sign,$oct)=@$matches;$oct =~ tr/_//d;my$result=oct$oct;$result= -$result if$sign eq '-';return$result}sub _from_hex {my ($constructor,$event,$matches)=@_;my ($sign,$hex)=@$matches;my$result=hex$hex;$result= -$result if$sign eq '-';return$result}sub _sexa_to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;my$result=0;my$i=0;my$sign=1;$float =~ s/^-// and $sign=-1;for my$part (reverse split m/:/,$float){$result += $part * (60 ** $i);$i++}$result=unpack F=>pack F=>$result;return$result * $sign}sub _to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;$float =~ tr/_//d;$float=unpack F=>pack F=>$float;return$float}sub _to_int {my ($constructor,$event,$matches)=@_;my ($int)=@$matches;$int =~ tr/_//d;0 + $int}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True y Y yes Yes YES on On ON/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False n N no No NO off Off OFF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_1_1=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX_1_1=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_1_1=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_BIN_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_SEXAGESIMAL_INT=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_SEXAGESIMAL=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],implicit=>0,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True y Y yes Yes YES on On ON false FALSE False n N n no No NO off Off OFF null NULL Null ~ .inf .Inf .INF -.inf -.Inf -.INF +.inf +.Inf +.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_1_1|$RE_FLOAT_1_1|$RE_INT_OCTAL_1_1|$RE_INT_HEX_1_1|$RE_INT_BIN_1_1|$RE_SEXAGESIMAL_INT|$RE_SEXAGESIMAL},code=>\&represent_literal,);if ($schema->bool_class){for my$class (@{$schema->bool_class}){$schema->add_representer(class_equals=>$class,code=>\&represent_bool,)}}return}1;
YAML_PP_SCHEMA_YAML1_1

$fatpacked{"YAML/PP/Type/MergeKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_TYPE_MERGEKEY';
  use strict;use warnings;package YAML::PP::Type::MergeKey;our$VERSION='0.036';sub new {my ($class)=@_;return bless {},$class}1;
YAML_PP_TYPE_MERGEKEY

$fatpacked{"YAML/PP/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER';
  use strict;use warnings;package YAML::PP::Writer;our$VERSION='0.036';sub output {return $_[0]->{output}}sub set_output {$_[0]->{output}=$_[1]}sub new {my ($class,%args)=@_;my$output=delete$args{output};$output='' unless defined$output;return bless {output=>$output,},$class}sub write {my ($self,$line)=@_;$self->{output}.= $line}sub init {$_[0]->set_output('')}sub finish {my ($self)=@_;$_[0]->set_output(undef)}1;
YAML_PP_WRITER

$fatpacked{"YAML/PP/Writer/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER_FILE';
  use strict;use warnings;package YAML::PP::Writer::File;our$VERSION='0.036';use Scalar::Util qw/openhandle/;use base qw/YAML::PP::Writer/;use Carp qw/croak/;sub _open_handle {my ($self)=@_;if (openhandle($self->{output})){$self->{filehandle}=$self->{output};return$self->{output}}open my$fh,'>:encoding(UTF-8)',$self->{output}or croak "Could not open '$self->{output}' for writing: $!";$self->{filehandle}=$fh;return$fh}sub write {my ($self,$line)=@_;my$fh=$self->{filehandle};print$fh $line}sub init {my ($self)=@_;my$fh=$self->_open_handle}sub finish {my ($self)=@_;if (openhandle($self->{output})){return}close$self->{filehandle}}1;
YAML_PP_WRITER_FILE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use v5.16;
use strict;

use Digest::MD5 ();
use File::Basename qw(basename dirname);
use File::Copy ();
use File::Find ();
use File::Path ();
use File::Spec;
use File::Temp ();
use File::Which ();
use File::pushd qw(pushd);
use GitHub::Release;
use HTTP::Tinyish;
use IPC::Run3 ();
use JSON::PP ();
use POSIX ();
use Parallel::Pipes::App;
use YAML::PP;

use constant DEBUG => $ENV{DEBUG} ? 1 : 0;

sub catpath { File::Spec->catfile(@_) }

my $TAR = qr/\.(?:tgz|tar\.(?:gz|bz2|xz))$/;
my $ZIP = qr/\.zip$/;
my $ARCHIVE = qr/(?:$TAR|$ZIP)/;

my $GIT = File::Which::which("git");
my $GO = File::Which::which("go");
my $JAVA = File::Which::which("java");
my $LOG_GO = "\e[1;35mGO!\e[m";

sub new {
    my ($class, %argv) = @_;
    my $home = $argv{home};
    my $base_dir = $argv{base_dir};
    my $cache_dir = catpath $base_dir, "cache";
    my $work_dir = catpath $base_dir, "work";
    my $jar_dir = catpath $base_dir, "jar";
    my $go_dir = catpath $base_dir, "go";
    File::Path::mkpath $_ for $base_dir, $cache_dir, $work_dir, $jar_dir, $go_dir;

    my $os = $^O =~ /linux/i ? "linux" : $^O =~ /darwin/i ? "darwin" : die;
    my $_arch = (POSIX::uname)[4];
    my %arch = (
        amd64   => "amd64",
        x86_64  => "amd64",
        arm64   => "arm64",
        aarch64 => "arm64",
    );
    my $arch = $arch{$_arch} or die "unsupported arch: $_arch";
    bless {
        os => $os,
        arch => $arch,
        home => $home,
        work_dir => $work_dir,
        cache_dir => $cache_dir,
        jar_dir => $jar_dir,
        go_dir => $go_dir,
        http => HTTP::Tinyish->new(verify_SSL => 1),
        github_release => GitHub::Release->new,
    }, $class;
}

sub run_with_log {
    my ($self, $name, @cmd) = @_;
    $self->log($name, "@cmd");
    my $pid = open my $fh, "-|";
    if ($pid == 0) {
        open STDERR, ">&", \*STDOUT;
        exec { $cmd[0] } @cmd;
        exit 1;
    }
    while (<$fh>) {
        $self->log($name, $_);
    }
    close $fh;
    $? == 0;
}

sub log {
    my ($self, $name, $msg) = @_;
    chomp $msg;
    warn "[\e[1;32m$name\e[m] $msg\n";
}

sub download {
    my ($self, $url) = @_;
    my $md5 = substr Digest::MD5::md5_hex($url), 0, 8;
    my $local_file = catpath $self->{cache_dir}, $md5 . "-" . basename($url);
    my $res = $self->{http}->mirror($url => $local_file);
    die "$res->{status}, $url\n" if !$res->{success};
    $local_file;
}

sub http_get {
    my ($self, $url) = @_;
    my $res = $self->{http}->get($url);
    die "$res->{status}, $url\n" if !$res->{success};
    $res->{content};
}

sub unpack {
    my ($self, $archive) = @_;
    my $tempdir = File::Temp::tempdir
        TEMPLATE => "unpack-XXXXX",
        CLEANUP => 0,
        DIR => $self->{work_dir},
    ;
    my $guard = pushd $tempdir;
    if ($archive =~ $TAR) {
        !system "tar", "xf", $archive or die;
    } elsif ($archive =~ $ZIP) {
        !system "unzip", "-q", $archive or die;
    } else {
        die;
    }
    $tempdir;
}

sub cleanup {
    my $self = shift;
    opendir my ($dh), $self->{work_dir} or die;
    my $one_week_ago = time - 7*24*60*60;
    my @obsolete =
        grep { (stat $_)[9] < $one_week_ago }
        map { catpath $self->{work_dir}, $_ }
        grep { /^unpack-/ }
        readdir $dh
    ;
    closedir $dh;
    for my $dir (@obsolete) {
        warn "Remove $dir\n";
        File::Path::rmtree $dir;
    }
}

sub probe_github_release {
    my ($self, @release) = @_;
    my ($want_os, $want_archs);
    if ($self->{os} eq "linux") {
        $want_os = qr/linux/i;
    } else {
        $want_os = qr/(?:darwin|macos|osx)/i;
    }
    if ($self->{arch} eq "amd64") {
        $want_archs = [qr/(?:amd64|x86_64)/i, qr/64/, qr/all/i];
    } else {
        $want_archs = [qr/(?:arm64|AArch64)/i, qr/(?:amd64|x86_64)/i, qr/64/, qr/all/i];
    }

    my @candidate;
    for my $i (0 .. $#{$want_archs}) {
        my $want_arch = $want_archs->[$i];
        for my $release (@release) {
            DEBUG and $i == 0 and warn $release;
            my $file = $release =~ s{.*/releases/download/}{}r;
            if ($file =~ $want_os && $file =~ $want_arch) {
                push @candidate, $release;
            }
        }
        last if @candidate;
    }
    if (!@candidate) {
        die "cannot probe release @release";
    }
    my $sort_by = sub {
        my ($b, $a) = @_;
        if ($b =~ $ARCHIVE && $a =~ $ARCHIVE) {
            return 0;
        } elsif ($b =~ $ARCHIVE) {
            return 1;
        } elsif ($a =~ $ARCHIVE) {
            return -1;
        } else {
            return 0;
        }
    };
    (sort { $sort_by->($b, $a) } @candidate)[0];
}

sub probe_local_version {
    my ($self, $target) = @_;
    if ($target =~ /kubectl$/) {
        IPC::Run3::run3 [$target, qw(version --client --output json)], \undef, \my $out, undef;
        my $v = JSON::PP::decode_json $out;
        return $v->{clientVersion}{gitVersion};
    }
    for my $option (qw(--version version -v -V --help help -h)) {
        my $out;
        IPC::Run3::run3 [$target, $option], \undef, \$out, \$out, { return_if_system_error => 1 };
        if ($? == -1) {
            DEBUG and warn "$target $option: $out";
            return;
        }
        if ($? == 0) {
            if ($out =~ /(\d+\.\d+\.\d+)/) {
                return $1;
            } elsif ($out =~ /(\d+\.\d+)/) {
                return $1;
            }
        }
        DEBUG and warn "$target $option: $out\n";
    }
    die "cannot probe version: $target";
}

sub probe_binary_in_dir {
    my ($self, $name, $dir) = @_;
    my $guard = pushd $dir;
    my @candidate;
    File::Find::find({no_chdir => 1, wanted => sub {
        my $file = $_;
        DEBUG and warn $file;
        return if !-f $file;
        if (basename($file) eq $name) {
            push @candidate, { file => $file, size => 1_000_000_000 };
        } elsif (-x $file) {
            my $size = (stat $file)[7];
            push @candidate, { file => $file, size => $size };
        }
    }}, ".");
    @candidate = sort { $b->{size} <=> $a->{size} } @candidate;
    if (@candidate) {
        return catpath $dir, $candidate[0]{file};
    }
    die "cannot find binary";
}

sub resolve_home {
    my ($self, $path) = @_;
    $path =~ s/^~/$self->{home}/r;
}

sub _binary_install {
    my ($self, $spec, $probe_latest_version, $probe_latest_url) = @_;
    my $name = $spec->{name};
    my $target = $self->resolve_home($spec->{target});

    if (-e $target and my $local_version = $self->probe_local_version($target)) {
        my $latest_version = $probe_latest_version->($spec);
        if ($latest_version =~ /$local_version/) {
            $self->log($name, "You have $local_version, latest_version $latest_version, OK");
            return 1;
        }
        $self->log($name, "You have $local_version, latest_version $latest_version, $LOG_GO");
    } else {
        $self->log($name, "You don't have one, $LOG_GO");
    }

    my $latest_url = $probe_latest_url->($spec);
    $self->log($name, "Downloading $latest_url");
    my $local_file = $self->download($latest_url);
    my $binary = $local_file;
    if ($local_file =~ $ARCHIVE) {
        my $dir = $self->unpack($local_file);
        $binary = $self->probe_binary_in_dir($name, $dir);
    }
    {
        my $dir = dirname $target;
        if (!-e $dir) {
            File::Path::mkpath $dir;
        }
    }
    $self->log($name, "Install $binary as $target");
    {
        my $tmp = "$target.tmp";
        File::Copy::copy $binary, $tmp or die "copy $binary, $tmp: $!";
        chmod 0755, $tmp or die;
        rename $tmp, $target or die "rename $tmp, $target: $!";
    }
    1;
}

sub github_install {
    my ($self, $spec) = @_;
    my $probe_latest_version = sub {
        my $spec = shift;
        $self->{github_release}->get_latest_tag($spec->{url});
    };
    my $probe_latest_url = sub {
        my $spec = shift;
        my @release = $self->{github_release}->get_latest_assets($spec->{url});
        $self->probe_github_release(@release);
    };
    $self->_binary_install($spec, $probe_latest_version, $probe_latest_url);
}

sub kubectl_install {
    my ($self, $spec) = @_;
    my $probe_latest_version = sub {
        $self->http_get("https://dl.k8s.io/release/stable.txt");
    };
    my $probe_latest_url = sub {
        my $version = $self->http_get("https://dl.k8s.io/release/stable.txt");
        "https://dl.k8s.io/release/$version/bin/$self->{os}/$self->{arch}/kubectl";
    };
    $self->_binary_install($spec, $probe_latest_version, $probe_latest_url);
}

sub spin_install {
    my ($self, $spec) = @_;
    my $probe_latest_version = sub {
        my $version = $self->http_get("https://storage.googleapis.com/spinnaker-artifacts/spin/latest");
        chomp $version;
        $version;
    };
    my $probe_latest_url = sub {
        my $version = $self->http_get("https://storage.googleapis.com/spinnaker-artifacts/spin/latest");
        chomp $version;
        "https://storage.googleapis.com/spinnaker-artifacts/spin/$version/$self->{os}/$self->{arch}/spin";
    };
    $self->_binary_install($spec, $probe_latest_version, $probe_latest_url);
}

sub helm_install {
    my ($self, $spec) = @_;
    my $url = "https://github.com/helm/helm";
    my $probe_latest_version = sub {
        my $spec = shift;
        $self->{github_release}->get_latest_tag($url);
    };
    my $probe_latest_url = sub {
        my $spec = shift;
        my $version = $self->{github_release}->get_latest_tag($url);
        "https://get.helm.sh/helm-$version-$self->{os}-$self->{arch}.tar.gz";
    };
    $self->_binary_install($spec, $probe_latest_version, $probe_latest_url);
}

sub git_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    if (!$GIT) {
        $self->log($name, "need git, skip");
        return;
    }
    my $target = $self->resolve_home($spec->{target});
    my $url = $spec->{url};
    if (-e $target) {
        my $guard = pushd $target;
        $self->run_with_log($name, $GIT, "pull") or die;
    } else {
        $self->run_with_log($name, $GIT, "clone", $url, $target) or die;
    }
}

sub go_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    if (!$GO) {
        $self->log($name, "need go, skip");
        return;
    }
    my $target = $self->resolve_home($spec->{target});
    if (-e $target) {
        IPC::Run3::run3 [$GO, "version"], undef, \my $out1, undef;
        my ($go_version) = $out1 =~ /go([0-9.]+)/;
        IPC::Run3::run3 [$GO, "version", $target], undef, \my $out2, undef;
        my ($target_version) = $out2 =~ /go([0-9.]+)/;
        if ($go_version eq $target_version) {
            $self->log($name, "You already have it, and it is built with go $go_version, OK");
            return 1;
        }
        $self->log($name, "You have it (built with go $target_version), $LOG_GO");
    } else {
        $self->log($name, "You don't have one, $LOG_GO");
    }
    my $package = $spec->{package};
    my $guard = pushd $self->{go_dir};
    $self->run_with_log($name, $GO, "install", $package) or die;
}

sub github_jar_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    if (!$JAVA) {
        $self->log($name, "need java, skip");
        return;
    }
    my $target = $self->resolve_home($spec->{target});
    my $url = $spec->{url};
    if (-e $target and my $local_version = $self->probe_local_version($target)) {
        my $latest_tag = $self->{github_release}->get_latest_tag($url);
        if ($latest_tag =~ /$local_version/) {
            $self->log($name, "You have $local_version, latest_tag $latest_tag, OK");
            return 1;
        }
        $self->log($name, "You have $local_version, latest_tag $latest_tag, $LOG_GO");
    } else {
        $self->log($name, "You don't have one, $LOG_GO");
    }

    my @release = $self->{github_release}->get_latest_assets($url);
    my ($release) = grep { /all-deps\.jar$/ } @release;
    if (!$release) {
        die "cannot find all-deps.jar in @release";
    }
    $self->log($name, "Downloading $release");
    my $jar_target = catpath $self->{jar_dir}, basename($release);
    my $res = $self->{http}->mirror($release => $jar_target);
    die "$res->{status}, $release" if !$res->{success};

    open my $fh, ">", $target or die;
    print {$fh} qq[#!/bin/bash\n];
    print {$fh} qq[exec java -jar $jar_target "\$@"\n];
    close $fh;
    chmod 0755, $target or die;
}

sub run {
    my ($self, $file) = @_;
    my ($yaml) = YAML::PP->new->load_file($file);

    my @task;
    for my $type (sort keys %$yaml) {
        if (!$self->can("${type}_install")) {
            warn "WARN: unknown type $type, skip\n";
            next;
        }
        for my $spec (@{$yaml->{$type}}) {
            next if exists $spec->{enabled} && !$spec->{enabled};
            if ($spec->{only}) {
                my $ok;
                for my $os_arch (split /\s*,\s*/, $spec->{only}) {
                    my ($os, $arch) = split m{/}, $os_arch;
                    if ($os eq $self->{os} and (!$arch or $arch eq $self->{arch})) {
                        $ok++, last;
                    }
                }
                next if !$ok;
            }
            my $priority = $spec->{priority} || 0;
            push @task, { type => $type, spec => $spec, priority => $priority };
        }
    }
    @task = sort { $a->{priority} <=> $b->{priority} } @task;
    my $work = sub {
        my $task = shift;
        my $method = "$task->{type}_install";
        eval { $self->$method($task->{spec}) };
        warn $@ if $@;
    };
    Parallel::Pipes::App->map(num => 2, tasks => \@task, work => $work);
    $self->cleanup;
}

my $file = shift;
if (!$file or $file =~ /^(-h|--help)$/) {
    die "Usage: binary-install spec.yaml\n";
}
my $home = (<~>)[0];
my $base_dir = catpath $home, ".binary-install";
my $app = __PACKAGE__->new(home => $home, base_dir => $base_dir);
$app->run($file);

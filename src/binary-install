#!/usr/bin/env perl
use 5.8.1;
use strict;
use warnings;

use Digest::MD5 ();
use File::Basename qw(basename dirname);
use File::Copy ();
use File::Find ();
use File::Path ();
use File::Spec;
use File::Temp ();
use File::Which ();
use File::pushd qw(pushd);
use Getopt::Long ();
use GitHub::Release;
use HTTP::Tinyish;
use IPC::Run3 ();
use POSIX ();
use Parallel::Pipes::App;
use YAML::PP;

use constant DEBUG => $ENV{DEBUG} ? 1 : 0;

our $VERSION = '0.0.1';

sub catpath { File::Spec->catfile(@_) }

my $TAR = qr/\.(?:tgz|tar\.(?:gz|bz2|xz))$/;
my $ZIP = qr/\.zip$/;
my $ARCHIVE = qr/(?:$TAR|$ZIP)/;

my $GIT = File::Which::which("git");
my $GO = File::Which::which("go");

sub new {
    my ($class, %argv) = @_;
    my $home = $argv{home};
    my $base_dir = $argv{base_dir};
    my $cache_dir = catpath $base_dir, "cache";
    my $work_dir = catpath $base_dir, "work";
    my $jar_dir = catpath $base_dir, "jar";
    File::Path::mkpath $_ for $base_dir, $cache_dir, $work_dir, $jar_dir;

    my $os = $^O =~ /linux/i ? "linux" : $^O =~ /darwin/i ? "darwin" : die;
    my $_arch = (POSIX::uname)[4];
    my $arch = $_arch eq "x86_64" ? "amd64" : $_arch eq "arm64" ? "arm64" : die;
    bless {
        os => $os,
        arch => $arch,
        home => $home,
        work_dir => $work_dir,
        cache_dir => $cache_dir,
        jar_dir => $jar_dir,
        http => HTTP::Tinyish->new(verify_SSL => 1),
        github_release => GitHub::Release->new,
    }, $class;
}

sub run_with_log {
    my ($self, $name, @cmd) = @_;
    $self->log($name, "@cmd");
    my $pid = open my $fh, "-|";
    if ($pid == 0) {
        open STDERR, ">&", \*STDOUT;
        exec { $cmd[0] } @cmd;
        exit 1;
    }
    while (<$fh>) {
        $self->log($name, $_);
    }
    close $fh;
    $? == 0;
}

sub log {
    my ($self, $name, $msg) = @_;
    chomp $msg;
    warn "[\e[1;32m$name\e[m] $msg\n";
}

sub download {
    my ($self, $url) = @_;
    my $md5 = substr Digest::MD5::md5_hex($url), 0, 8;
    my $local_file = catpath $self->{cache_dir}, $md5 . "-" . basename($url);
    my $res = $self->{http}->mirror($url => $local_file);
    die "$res->{status}, $url\n" if !$res->{success};
    $local_file;
}

sub unpack {
    my ($self, $archive) = @_;
    my $tempdir = File::Temp::tempdir
        TEMPLATE => "unpack-XXXXX",
        CLEANUP => 0,
        DIR => $self->{work_dir},
    ;
    my $guard = pushd $tempdir;
    if ($archive =~ $TAR) {
        !system "tar", "xf", $archive or die;
    } elsif ($archive =~ $ZIP) {
        !system "unzip", "-q", $archive or die;
    } else {
        die;
    }
    $tempdir;
}

sub cleanup {
    my $self = shift;
    opendir my ($dh), $self->{work_dir} or die;
    my $one_week_ago = time - 7*24*60*60;
    my @obsolete =
        grep { (stat $_)[9] < $one_week_ago }
        map { catpath $self->{work_dir}, $_ }
        grep { /^unpack-/ }
        readdir $dh
    ;
    closedir $dh;
    for my $dir (@obsolete) {
        warn "Remove $dir\n";
        File::Path::rmtree $dir;
    }
}

sub probe_release {
    my ($self, @release) = @_;
    my ($want_os, $want_archs);
    if ($self->{os} eq "linux") {
        $want_os = qr/linux/i;
    } else {
        $want_os = qr/(?:darwin|macos|osx)/i;
    }
    if ($self->{arch} eq "amd64") {
        $want_archs = [qr/(?:amd64|x86_64)/i, qr/64/, qr/all/i];
    } else {
        $want_archs = [qr/(?:arm64|AArch64)/i, qr/(?:amd64|x86_64)/i, qr/64/, qr/all/i];
    }

    my @candidate;
    for my $i (0 .. $#{$want_archs}) {
        my $want_arch = $want_archs->[$i];
        for my $release (@release) {
            DEBUG and $i == 0 and warn $release;
            (my $file = $release) =~ s{.*/releases/download/}{};
            if ($file =~ $want_os && $file =~ $want_arch) {
                push @candidate, $release;
            }
        }
        last if @candidate;
    }
    if (!@candidate) {
        die "cannot probe release @release";
    }
    my $sort_by = sub {
        my ($b, $a) = @_;
        if ($b =~ $ARCHIVE && $a =~ $ARCHIVE) {
            return 0;
        } elsif ($b =~ $ARCHIVE) {
            return 1;
        } elsif ($a =~ $ARCHIVE) {
            return -1;
        } else {
            return 0;
        }
    };
    (sort { $sort_by->($b, $a) } @candidate)[0];
}

sub probe_local_version {
    my ($self, $target) = @_;
    for my $option (qw(--version version -v -V --help help -h)) {
        my $out;
        IPC::Run3::run3 [$target, $option], \undef, \$out, \$out, { return_if_system_error => 1 };
        if ($? == -1) {
            DEBUG and warn "$target $option: $out";
            return;
        }
        if ($? == 0) {
            if ($out =~ /(\d+\.\d+\.\d+)/) {
                return $1;
            } elsif ($out =~ /(\d+\.\d+)/) {
                return $1;
            }
        }
        DEBUG and warn "$target $option: $out\n";
    }
    die "cannot probe version: $target";
}

sub probe_binary_in_dir {
    my ($self, $name, $dir) = @_;
    my $guard = pushd $dir;
    my @candidate;
    File::Find::find({no_chdir => 1, wanted => sub {
        my $file = $_;
        DEBUG and warn $file;
        return if !-f $file;
        if (basename($file) eq $name) {
            push @candidate, { file => $file, size => 1_000_000_000 };
        } elsif (-x $file) {
            my $size = (stat $file)[7];
            push @candidate, { file => $file, size => $size };
        }
    }}, ".");
    @candidate = sort { $b->{size} <=> $a->{size} } @candidate;
    if (@candidate) {
        return catpath $dir, $candidate[0]{file};
    }
    die "cannot find binary";
}

sub binary_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    my $github_url = $spec->{github_url};
    my $target = $self->resolve_home($spec->{target});

    if (-e $target and my $local_version = $self->probe_local_version($target)) {
        my $latest_tag = $self->{github_release}->get_latest_tag($github_url);
        if ($latest_tag =~ /$local_version/) {
            $self->log($name, "You have $local_version, latest_tag $latest_tag, OK");
            return 1;
        }
        $self->log($name, "You have $local_version, latest_tag $latest_tag, GO!");
    } else {
        $self->log($name, "You don't have one, GO!");
    }

    my @release = $self->{github_release}->get_latest_assets($github_url);
    my $release = $self->probe_release(@release);
    $self->log($name, "Downloading $release");
    my $local_file = $self->download($release);
    my $binary = $local_file;
    if ($local_file =~ $ARCHIVE) {
        my $dir = $self->unpack($local_file);
        $binary = $self->probe_binary_in_dir($name, $dir);
    }
    {
        my $dir = dirname $target;
        if (!-e $dir) {
            File::Path::mkpath $dir;
        }
    }
    $self->log($name, "Install $binary as $target");
    {
        my $tmp = "$target.tmp";
        File::Copy::copy $binary, $tmp or die "copy $binary, $tmp: $!";
        chmod 0755, $tmp or die;
        rename $tmp, $target or die "rename $tmp, $target: $!";
    }
    1;
}

sub resolve_home {
    my ($self, $path) = @_;
    $path =~ s/^~/$self->{home}/;
    $path;
}

sub git_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    if (!$GIT) {
        $self->log($name, "need git, skip");
        return;
    }
    my $target = $self->resolve_home($spec->{target});
    my $url = $spec->{url};
    if (-e $target) {
        my $guard = pushd $target;
        $self->run_with_log($name, $GIT, "pull") or die;
    } else {
        $self->run_with_log($name, $GIT, "clone", $url, $target) or die;
    }
}

sub go_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    if (!$GO) {
        $self->log($name, "need go, skip");
        return;
    }
    my $target = $self->resolve_home($spec->{target});
    if (-e $target && !$ENV{FORCE}) {
        $self->log($name, "You already have it, OK (you can set FORCE=1)");
        return 1;
    }
    my $package = $spec->{package};
    my $guard = pushd $self->{cache_dir};
    $self->run_with_log($name, $GO, "install", $package) or die;
}

sub jar_install {
    my ($self, $spec) = @_;
    my $name = $spec->{name};
    my $target = $self->resolve_home($spec->{target});
    if (-e $target && !$ENV{FORCE}) {
        $self->log($name, "You already have it, OK (you can set FORCE=1)");
        return 1;
    }
    my $github_url = $spec->{github_url};
    my @release = $self->{github_release}->get_latest_assets($github_url);
    my ($release) = grep { /all-deps\.jar$/ } @release;
    if (!$release) {
        die "cannot find all-deps.jar in @release";
    }
    $self->log($name, "Downloading $release");
    my $jar_target = catpath $self->{jar_dir}, basename($release);
    my $res = $self->{http}->mirror($release => $jar_target);
    die "$res->{status}, $release" if !$res->{success};

    open my $fh, ">", $target or die;
    print {$fh} qq[#!/bin/bash\n];
    print {$fh} qq[exec java -jar $jar_target "\$@"\n];
    close $fh;
    chmod 0755, $target or die;
}

sub run {
    my ($self, $file) = @_;
    my ($yaml) = YAML::PP->new->load_file($file);

    Parallel::Pipes::App->map(
        num => 2,
        tasks => [
            ( map +{ type => "binary", spec => $_ }, @{ $yaml->{binary} || [] } ),
            ( map +{ type => "git", spec => $_ }, @{ $yaml->{git} || [] } ),
            ( map +{ type => "go", spec => $_ }, @{ $yaml->{go} || [] } ),
            ( map +{ type => "jar", spec => $_ }, @{ $yaml->{jar} || [] } ),
        ],
        work => sub {
            my $task = shift;
            my $method = "$task->{type}_install";
            if (exists $task->{spec}{enabled} && !$task->{spec}{enabled}) {
                return;
            }
            eval { $self->$method($task->{spec}) };
            warn $@ if $@;
        },
    );
    $self->cleanup;
}

Getopt::Long::Parser->new(
    config => [qw(no_auto_abbrev no_ignore_case bundling)],
)->getoptionsfromarray(\@ARGV,
    "h|help" => sub { die "Usage: binary-install spec.yaml\n" },
    "v|version" => sub { print "binary-install $VERSION\n"; exit },
) or exit;

my $file = shift or die "missing spec.yaml\n";
my $home = (<~>)[0];
my $base_dir = catpath $home, ".binary-install";
my $app = __PACKAGE__->new(home => $home, base_dir => $base_dir);
$app->run($file);

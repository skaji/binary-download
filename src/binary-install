#!/usr/bin/env perl
use 5.8.1;
use strict;
use warnings;

use Digest::MD5 ();
use File::Basename qw(basename);
use File::Copy ();
use File::Find ();
use File::Path ();
use File::Spec;
use File::Temp ();
use File::pushd qw(pushd);
use Getopt::Long ();
use IPC::Run3 ();
use POSIX ();
use YAML::PP;

use constant DEBUG => $ENV{DEBUG} ? 1 : 0;

our $VERSION = '0.0.1';

{
    package HTTP;
    use parent 'HTTP::Tinyish::Curl';
    sub new {
        my ($class, %argv) = @_;
        $class->configure;
        $class->supports("https") or die "missing curl";
        $class->SUPER::new(verify_SSL => 1, agent => "Mozilla/5.0", %argv);
    }
    sub build_options {
        my ($self, $url, $opts) = @_;
        my @option = $self->SUPER::build_options($url, $opts);
        if (exists $self->{max_redirect} && !$self->{max_redirect}) {
            my @new = ("--no-location");
            while (my $option = shift @option) {
                if ($option eq "--location") {
                    next;
                }
                if ($option eq "--max-redirs") {
                    shift @option;
                    push @new, "--max-redirs", 0;
                    next;
                }
                push @new, $option;
            }
            @option = @new;
        }
        @option;
    }
}

sub catpath { File::Spec->catfile(@_) }
my $TAR = qr/\.(?:tgz|tar\.(?:gz|bz2|xz))$/;
my $ZIP = qr/\.zip$/;
my $ARCHIVE = qr/(?:$TAR|$ZIP)/;

sub new {
    my ($class, $base_dir, $target_dir) = @_;
    my $cache_dir = catpath $base_dir, "cache";
    my $work_dir = catpath $base_dir, "work";
    File::Path::mkpath $_ for $base_dir, $cache_dir, $work_dir, $target_dir;

    my $os = $^O =~ /linux/i ? "linux" : $^O =~ /darwin/i ? "darwin" : die;
    my $_arch = (POSIX::uname)[4];
    my $arch = $_arch eq "x86_64" ? "amd64" : $_arch eq "arm64" ? "arm64" : die;
    bless {
        os => $os,
        arch => $arch,
        work_dir => $work_dir,
        cache_dir => $cache_dir,
        target_dir => $target_dir,
        http => HTTP->new,
        http_no_redirect => HTTP->new(max_redirect => 0),
    }, $class;
}

sub download {
    my ($self, $url) = @_;
    my $md5 = substr Digest::MD5::md5_hex($url), 0, 8;
    my $local_file = catpath $self->{cache_dir}, $md5 . "-" . basename($url);
    my $res = $self->{http}->mirror($url => $local_file);
    die "$res->{status}, $url\n" if !$res->{success};
    $local_file;
}

sub unpack {
    my ($self, $archive) = @_;
    my $tempdir = File::Temp::tempdir
        TEMPLATE => "unpack-XXXXX",
        CLEANUP => 0,
        DIR => $self->{work_dir},
    ;
    my $guard = pushd $tempdir;
    if ($archive =~ $TAR) {
        !system "tar", "xf", $archive or die;
    } elsif ($archive =~ $ZIP) {
        !system "unzip", "-q", $archive or die;
    } else {
        die;
    }
    $tempdir;
}

sub cleanup {
    my $self = shift;
    opendir my ($dh), $self->{work_dir} or die;
    my $one_week_ago = time - 7*24*60*60;
    my @obsolete =
        grep { (stat $_)[9] < $one_week_ago }
        map { catpath $self->{work_dir}, $_ }
        grep { /^unpack-/ }
        readdir $dh
    ;
    closedir $dh;
    for my $dir (@obsolete) {
        warn "Remove $dir\n";
        File::Path::rmtree $dir;
    }
}

sub get_github_latest_tag {
    my ($self, $url) = @_;
    $url = "$url/releases/latest";
    my $res = $self->{http_no_redirect}->get($url);
    if ($res->{status} !~ /^3/) {
        die "$res->{status}, $url\n";
    }
    my $loc = $res->{headers}{location};
    (split /\//, $loc)[-1];
}

sub get_github_latest_releases {
    my ($self, $url) = @_;
    $url = "$url/releases/latest";
    my $res = $self->{http}->get($url);
    if (!$res->{success}) {
        die "$res->{status}, $url\n";
    }
    my @href = $res->{content} =~ m{ href="(.+?)" }xgi;
    map { m{^https} ? $_ : "https://github.com$_" } grep { m{/releases/download/} } @href;
}

sub probe_release {
    my ($self, @release) = @_;
    my ($want_os, $want_archs);
    if ($self->{os} eq "linux") {
        $want_os = qr/linux/i;
    } else {
        $want_os = qr/(?:darwin|macos|osx)/i;
    }
    if ($self->{arch} eq "amd64") {
        $want_archs = [qr/(?:amd64|x86_64)/i, qr/64/];
    } else {
        $want_archs = [qr/(?:arm64|AArch64)/i, qr/(?:amd64|x86_64)/i, qr/64/];
    }

    my @candidate;
    for my $i (0 .. $#{$want_archs}) {
        my $want_arch = $want_archs->[$i];
        for my $release (@release) {
            DEBUG and $i == 0 and warn $release;
            (my $file = $release) =~ s{.*/releases/download/}{};
            if ($file =~ $want_os && $file =~ $want_arch) {
                push @candidate, $release;
            }
        }
        last if @candidate;
    }
    if (!@candidate) {
        die "cannot probe release @release";
    }
    my $sort_by = sub {
        my ($b, $a) = @_;
        if ($b =~ $ARCHIVE && $a =~ $ARCHIVE) {
            return 0;
        } elsif ($b =~ $ARCHIVE) {
            return 1;
        } elsif ($a =~ $ARCHIVE) {
            return -1;
        } else {
            return 0;
        }
    };
    (sort { $sort_by->($b, $a) } @candidate)[0];
}

sub probe_local_version {
    my ($self, $name) = @_;
    for my $option (qw(--version version -v -V --help help -h)) {
        my $out;
        my $bin = catpath $self->{target_dir}, $name;
        IPC::Run3::run3 [$bin, $option], \undef, \$out, \$out, { return_if_system_error => 1 };
        if ($? == -1) {
            DEBUG and warn "$bin $option: $out";
            return;
        }
        if ($? == 0) {
            if ($out =~ /(\d+\.\d+\.\d+)/) {
                return $1;
            } elsif ($out =~ /(\d+\.\d+)/) {
                return $1;
            }
        }
        DEBUG and warn "$bin $option: $out\n";
    }
    die "cannot probe version";
}

sub probe_binary_in_dir {
    my ($self, $name, $dir) = @_;
    my $guard = pushd $dir;
    my @candidate;
    File::Find::find({no_chdir => 1, wanted => sub {
        my $file = $_;
        DEBUG and warn $file;
        return if !-f $file;
        if (basename($file) eq $name) {
            push @candidate, { file => $file, size => 1_000_000_000 };
        } elsif (-x $file) {
            my $size = (stat $file)[7];
            push @candidate, { file => $file, size => $size };
        }
    }}, ".");
    @candidate = sort { $b->{size} <=> $a->{size} } @candidate;
    if (@candidate) {
        return catpath $dir, $candidate[0]{file};
    }
    die "cannot find binary";
}

sub install {
    my ($self, $argv) = @_;
    my $name = $argv->{name};
    my $gihtub_url = $argv->{github_url};

    if (my $local_version = $self->probe_local_version($name)) {
        my $latest_tag = $self->get_github_latest_tag($gihtub_url);
        if ($latest_tag =~ /$local_version/) {
            warn "[$name] You have $local_version, latest_tag $latest_tag, OK\n";
            return 1;
        }
        warn "[$name] You have $local_version, latest_tag $latest_tag, GO!\n";
    } else {
        warn "[$name] You don't have one, GO!\n";
    }

    my @release = $self->get_github_latest_releases($gihtub_url);
    my $release = $self->probe_release(@release);
    warn "[$name] Downloading $release\n";
    my $local_file = $self->download($release);
    my $binary = $local_file;
    if ($local_file =~ $ARCHIVE) {
        my $dir = $self->unpack($local_file);
        $binary = $self->probe_binary_in_dir($name, $dir);
    }
    my $target = catpath $self->{target_dir}, $name;
    warn "[$name] Install $binary as $target\n";
    {
        my $tmp = "$target.tmp";
        File::Copy::copy $binary, $tmp or die "copy $binary, $tmp: $!";
        chmod 0755, $tmp or die;
        rename $tmp, $target or die "rename $tmp, $target: $!";
    }
    1;
}

sub run {
    my ($self, $file) = @_;
    my ($yaml) = YAML::PP->new->load_file($file);
    for my $binary (@{ $yaml->{binaries} }) {
        $self->install($binary);
    }
    $self->cleanup;
}

Getopt::Long::Parser->new(
    config => [qw(no_auto_abbrev no_ignore_case bundling)],
)->getoptionsfromarray(\@ARGV,
    "h|help" => sub { die "Usage: binary-install spec.yaml\n" },
    "v|version" => sub { print "binary-install $VERSION\n"; exit },
) or exit;

my $file = shift or die "missing spec.yaml\n";
my $home = (<~>)[0];
my $base_dir = catpath $home, ".binary-install";
my $target_dir = catpath $home, "bin";
my $app = __PACKAGE__->new($base_dir, $target_dir);
$app->run($file);
